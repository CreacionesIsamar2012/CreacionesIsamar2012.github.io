
// @ sourceMappingURL = jquery.min.map
* / (Función (e, t) {var n, r, i = typeof t, o = e.document, a = e.location, s = e.jQuery, u = e. $, L = {}, c = [], p = "1.9.1", f = c.concat, d = c.push, h = c.slice, g = c.indexOf, m = l.toString, y = l.hasOwnProperty, v = p.trim, b = function (e, t) {return new b.fn.init (e, t, r)}, x = / [+ -]? (?:. \ d * \ |) \ d + ( ?:?. [eE] [+ -] \ d + |) / fuente, w = / \ S + / g, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, N = / ^ (?: (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, C = / ^ <(\ w +) \ ? s * \ /> (:? <\ / \ 1> |) $ /, k = / ^ [\], {} \ s] * $ /, E = / (: ^ |: |,) (?: \ s * \ [) + / g, S = / \\ (?: [ "\\\ / bfnrt] | u [\ da-fA-F] {4}) / g, A = /" [^ "\\\ r \ n] *" | true | false | nula | -: | \ d +? (\ d + \?.) (?:? [eE] [+ -] \ d + |) / g, j = / ^ - ms - /, D = / - ([\ da-z]) / gi, L = función (e, t) {return t.toUpperCase ()}, H = función (e) {(O .addEventListener || "carga" === e.type || "completo" === o.readyState) && (q (), b.ready ())}, q = function () {o.addEventListener? ( o.removeEventListener ( "DOMContentLoaded", H,! 1), e.removeEventListener ( "carga", H,! 1)) :( o.detachEvent ( "onreadystatechange", H), e.detachEvent ( "onload", H ))}; b.fn = b.prototype = {jQuery: p, constructor: b, init: función (e, n, r) {var i, a; si (e) devolver esto, si ( "cadena" == typeof e) {if (I = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3 [null, e, null]:? N.exec (e) ,! i || i [1] && n) devuélvalo n || n.jquery (n || r) .find (e):!? this.constructor (n) .find (e), si ( i [1]) {if (n = n instanceof b n [0]:?? n, b.merge (esto, b.parseHTML (i [1], n && n.nodeType n.ownerDocument || n: o ,! 0)), C.test (i [1]) && b.isPlainObject (n)) para (i n) b.isFunction (esta [i]) esta [i] (n [i]):? this.attr (i, n [i]); retorno este} if (a = o.getElementById (i [2]), una && a.parentNode) {if (! a.id == i [2]) de retorno r.find (e ); this.length = 1, esta [0] = a} return this.context = O, this.selector = e, esta} volver e.nodeType (this.context = esta [0] = e, this.length? = 1, este):?! b.isFunction (e) r.ready (e) :( e.selector == t && (this.selector = e.selector, this.context = e.context), b.makeArray ( e, este))}, el selector: "", longitud: 0, tamaño: function () {return this.length}, toArray: function () {return h.call (este)}, obtener: function (e) { devolver null == e this.toArray ():?? 0> e esta [this.length + e]: esta [e]}, pushStack: function (e) {var t = b.merge (this.constructor () , e); volver t.prevObject = este, t.context = this.context, t}, cada uno: función (e, t) {b.each retorno (esto, e, t)}, listo: function (e) {b.ready.promise retorno () hecho (e), esto.}, rebanada: function () {return this.pushStack (h.apply (esto, argumentos))}, en primer lugar: la función () {return this.eq (0)}, última: function () {return this.eq (-1)}, eq: function (e) { var t = this.length, n = + e + (0> e t:? 0); regreso this.pushStack (n> = 0 && t> n [esta [n]]: []?)}, mapa: function (e ) {return this.pushStack (b.map (esto, la función (t, n) {return e.call (t, n, t)}))}, final: function () {return this.prevObject || esto. constructor (null)}, pulse: d, tipo:. [] especie, empalme:. [] empalme}, b.fn.init.prototype = b.fn, b.extend = b.fn.extend = function () {var e, n, r, i, o, a, s = argumentos [0] || {}, u = 1, l = arguments.length, c = 1;! para ( "boolean" == typeof es && ( c = s, s = argumentos [1] || {}, u = 2), "objeto" == typeof s || b.isFunction (s) || (s = {}), l === u && ( s = este, - u);! l> u, u ++) if (null = (o = argumentos [u])) para (i en o) e = s [i], r = o [i], s ! == r && (c && r && (b.isPlainObject (r) || (n = b.isArray (r))) (n (n = 1, a = e && b.isArray (e) e:??!? []) ?: a = e && b.isPlainObject (e) e: {}, s [i] = b.extend (C, a, R)): r == t && (s [i] = r)); retorno s} , b.extend ({noConflict: function (t) { E Vuelva $ === b && (e $ = u.), t && e.jQuery === b && (e.jQuery = s), b}, isReady:.! 1, readyWait: 1, holdReady: function (e) { ? e b.readyWait ++: b.ready}, listo: function (e) {if (0)! (e === 0 - b.readyWait:!?! b.isReady) {if (o.body ) volver setTimeout (b.ready); b.isReady = 0, e == 0 && - b.readyWait> 0 || (n.resolveWith (O, [b]!!!), b.fn.trigger && b (O ) .trigger ( "listo") fuera ( "listo"))}}, isFunction:. función (e) {return "función" === b.type (e)}, isArray: función Array.isArray || ( e) {return "matriz" === b.type (e)}, IsWindow: function (e) {return null = && correo electrónico == e.window!}, isNumeric: function (e) {return isNaN (parseFloat (! e)) && isFinite (e)}, tipo: function (e) {return nula == e e + "?": "? función" == typeof e || "objeto" == typeof e l [m.call (e )] || "objeto": typeof e}, isPlainObject: function (! e) {if (e || "objeto" == b.type (e) || || e.nodeType b.isWindow (e) ) devuelve 1;! try {si (e.constructor && y.call (e, "constructor"!) && y.call (e.constructor.prototype, "isPrototypeOf")) return 1!} catch (n) {return ! 1} var r; for (r en e); return r === t || y.call (e, r)}, isEmptyObject: función (e) {var t; para (t en e) devuelve 1 ; return 0}, se equivocan! o: function (e) {error tiro (e)}, ParseHTML: function (e, t, n) {if (! e || "cadena" = typeof e) return null; "booleano" == typeof t && ( n = t, t = 1), t = t || O;! var r = C.exec (e), i = n && [];!? retorno r [t.createElement (r [1])] :( r = b.buildFragment ([e], t, i), i && b (i) .Remove (), b.merge ([], r.childNodes))}, parseJSON: function (n) {return e.JSON && e. ? JSON.parse e.JSON.parse (n): === nula n n:? "string" == typeof n && (n = b.trim (n), n && k.test (n.replace (S, "@ ") .replace (A,"] ") en lugar de (E," "))) Función (" retorno "+ n) () :( b.error (" JSON válido: "? + n), t)} , parseXML:; (! n || "cadena" = typeof n)? función (n) {var r, i si es devuelto nulo; try {e.DOMParser (i = new DOMParser, r = i.parseFromString (n, "text / xml")) :( r = new ActiveXObject ( "Microsoft.XMLDOM"), r.async = "false", r.loadXML (n))} catch (o) {r} = t r retorno && && r.documentElement ! r.getElementsByTagName ( "parsererror") de longitud || b.error ( "XML no válido:" + n)., r}, NOOP: function () {}, globalEval: function (t) {t && b.trim (t) && (e.execScript || función (t) {e.eval.call (e, t)}) (t)}, camelCase:. función (e) {return e.replace (j, "ms") - reemplazar (D, L)}, nombreNodo: function (e , T) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, cada uno: función (e, t, n) {var r, i = 0, o = e.length, a = M (e), si (n) {if (a) {for (; o> i; i ++) if (! r = t.apply (e [i], n), r === 1) salto} else para (i en e) si (r = t.apply (e [i], n), r === 1!) descanso} else if (a) {for (; o> i; i ++) si (r = t.call (e [i], i, e [i]), r ===! 1) rotura} else para (i en e) si (r = t.call (e [i], i, e [ !?!? i]), r === 1) romper; e} regresar, el asiento: v && v.call ( "\ ufeff \ u00a0") función (e) {return nula e == "": v.call (e)}: function (e) {return null == e "" :( e + "") sustituir (T, "")}, MakeArray:?. función (e, t) {var n = t || [ ]; devuelto nulo e = && (H (Object (e)) b.merge (n, "cadena" == typeof e [e]:?? e): d.call (n, e))!, n}, InArray:? función (e, t, n) {var r; si (t) {if (g) de retorno g.call (t, e, n); para (r = t.length, n = n 0> n ? Math.max (0, r + n): n: 0; r> n; n ++) si (n en t && t [n] === e) retorno n} volver-1}, combinar: function (e, n ) {var r = n.length, i = e.length, o = 0; si ( "número" == typeof r) para (; r> O; o ++) e [i ++] = n [o]; cosa mientras (! n [o] == t) e [i ++] = n [o ++]; retorno e.length = i, e}, grep: function (e, t, n) {var r, i = [], o = 0, a = e.length; for (n = !! n; a> O; o ++) r = !! t (e [o], o), n == r && i.push (e [o])! ;retirado urna i}, mapa: function (e, t, n) {var r, i = 0, o = e.length, a = M (e), s = []; si (a) para (; o> i ; i ++) r = t (e [i], i, n), null = r && (s [s.length] = r);! else para (i en e) r = t (e [i], i, ! n), null = r && (s [s.length] = r); volver f.apply ([], s)}, GUID: 1, Proxy: function (e, n) {var r, i, o; volver "string" == typeof n && (O = e [n], n = e, e = o), b.isFunction (e)? (r = h.call (argumentos, 2), i = function () { volver e.apply (n || esto, r.concat (h.call (argumentos)))}, i.guid = e.guid = e.guid || b.guid ++, i): t}, acceso: función (e, n, r, i, o, a, s) {var u = 0, l = e.length, c = null == r; si ( "objeto" === b.type (r)) { o = 0;! para (u en r) b.access (e, n, u, r [u] ,! 0, a, s)} else if (i == t && (o = 0, b!. isFunction (i) || (s = 0), c && (s? (n.call (e, i), n = null) :( c = n, n = function (e, t, n) {return c .call (b (e), n)})), n)) para (; l> u; u ++) n (e [u], r, s i:? i.call (e [u], u, n (e [u], r))); O RETURN e: c n.call (e): l n (e [0], r): a}, ahora: function () {return (nuevo??? fecha) .getTime ()}}), b.ready.promise = function (t) {if (! n) si (n = b.Deferred (), "completo" === o.readyState) setTimeout (b. listo);! else if (o.addEventListener) o.addEventListener ( "DOMContentLoaded", H, 1), e.addEventListener ( "carga", H, ! 1); else {o.attachEvent ( "onreadystatechange", H), e.attachEvent ( "onload", H); var r = 1;! Try {r = null == e.frameElement && o.documentElement} catch (i )} {r && && r.doScroll función a () {if (! b.isReady) {try {r.doScroll ( "izquierda")} catch (e) {return setTimeout (a, 50)} q (), b.ready ( )}} ()} return n.promise (t)}, b.each ( "Número de Boole cadena de error función array Fecha RegExp objeto" .split ( " "), la función (e, t) {l ["[objeto" + t + "]"] = t.toLowerCase ()}); función M (e) {var t = e.length, n = b.type (e); volver b.isWindow (e) ?! 1: 1 = == e.nodeType && t 0:?! "array" === n || "función" == n && (0 === t || "número" == typeof t && t> 0 && t-1 en e)} r = b (o); var _ = {}; función F (e) {var t = _ [e] = {}; retorno b.each (e.match (w) || [], la función (e, n) {t [n] = 0}), t} b.Callbacks = function (e) {e = "cadena" == typeof e _ [e] || F (e):? b.extend ({}, e);! var n, r, i, o, a, s, u = [], l = e.once && [], c = función (t) {for (r = e.memory && t, i = 0, a = s || 0, s = 0, o = u.length, n = 0;! u && o> a; a ++) si (u [a] .apply (t [0], t [1]) === ! 1 && e.stopOnFalse) {r = 1; descanso!} n = 1, u && (l l.length && c (l.shift ()?):!? r u = []: p.disable ())}, p = {añadir: function () {if (u) {var t = u.length; ( función de i (t) {b.each (t, la función (t, n) {var r = b.type (n);? "función" === r e.unique && p.has (n) || u.push (n): n && n.length && "cadena" == r && i (n)})}) (argumentos), n o = u.length:!? r && (s = t, c (r))} devolver esta}, remover : function () {return u && b.each (argumentos, la función (e, t) {var r; while ((r = b.inArray (t, u, r))> - 1) u.splice (r, 1) , n && (o> = r && o -, a> = r && a -)}), esto}, tiene: function (e) {return e b.inArray (e, u)> - 1:?! (u | ! | u.length)}, vacío: function () {return u = [], esto}, deshabilitar: function () {return u = l = r = t, esto}, discapacitados: function () {return u! !}, cerradura: function () {return l = t p.disable, r || (), esta}, bloqueado: function () {return l}, fireWith: function (e, t) {return t = t | | [], t = [e, t.slice t.slice ():? t]! ,! u || i && || l (? n l.push (t): c (t)), esto}, fuego: function () {p.fireWith retorno (esta, argumentos), esto}, disparó: function () {return !! i}}; retorno p}, b.extend ({diferido: function (e) {var t = [[ "resolver", "hecho", b.Callbacks ( "una vez que la memoria"), "resueltos"], [ "rechazo", "falla", b.Callbacks ( "una vez que la memoria"), "rechazaron"], [ "notificar", "progreso", b.Callbacks ( "memoria")]], n = "pendiente", r = {Estado: function () {return n }, Siempre: function () {return i.done (argumentos) .fail (argumentos), esta}, entonces: function () {var e = argumentos; regreso b.Deferred (function (n) {b.each (t , la función (t, o) {var a = O [0], s = b.isFunction (e [t]) && e [t]; i [o [1]] (function () {var e = s && s.apply (esto, argumentos); e && b.isFunction (e.promise) e.promise () hecho (n.resolve) .fail (n.reject) .progress (n.notify):?. n [a + "con"] ( esta === r n.promise ():? esto, s [e]: argumentos)})}), e = null}) promesa ()}, promesa:.! función (e) {return null = e ? b.extend (e, r): r}}, i = {}; retorno r.pipe = r.then, b.each (t, la función (e, o) {var a = o [2], s = o [3]; r [o [1]] = a.add, s && a.add (function () {n = s}, t [1 ^ e] [2] .disable, t [2] [2] .lock), i [o [0]] = function () {return i [o [0] + "con"] (esto === i r:? esto, argumentos), esta}, i [o [0 ] + "con"] = a.fireWith}), r.promise (i), e && e.call (i, i), i}, cuando: function (e) {var t = 0, n = h.call ( argumentos), r = n.length, i = 1 == r || e && b.isFunction (e.promise) r:!? 0, o = 1 === i e:? b.Deferred (), una función = (e, t, n) {función de retorno (r) {t [e] = este, n [e] = arguments.length> 1 h.call (argumentos):?? R, N === s o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, s, u, l; si (r> 1) para la (s = Array (r), u = Array (r), l = Array (r); r> t; t ++) n [t] && b.isFunction (n [t] .promise) ? n [t] .promise () hecho (a (t, l, n)) fallar (o.reject) .progress (a (t, u, s)): -.. i; i || o de retorno .resolveWith (l, n), o.promise ()}}), b.support = function () {var t, n, r, a, s, u, l, c, p, f, d = O. createElement ( "div"), si (d.setAttribute ( "className", "t"), d.innerHTML ="<link /> <table> </ table> <a href='/a'> a </ a> <input type = 'casilla de verificación' />", n = d.getElementsByTagName ( "*"), r = d.getElementsByTagName ( "a") [0] ,! n ||! r ||! n.length ) de retorno {}; s = o.createElement ( "seleccionar"), l = s.appendChild (o.createElement ( "opción")), a = d.getElementsByTagName ( "input") [0], r.style. cssText = "top: 1px; float: left; opacidad: 0,5"!, t = {getSetAttribute: "t" == d.className, leadingWhitespace: 3 === d.firstChild.nodeType, tbody: d.getElementsByTagName! . ( "tbody") de longitud, htmlSerialize:. !! d.getElementsByTagName ( "link") de longitud, el estilo: /top/.test (( "estilo" r.getAttribute)), hrefNormalized: "/ a" === r.getAttribute ( "href"), la opacidad: / ^ 0.5 / .test (r.style.opacity), cssFloat: !! r.style.cssFloat, checkOn: !! a.value, optSelected: l.selecte d, enctype:. !! o.createElement ( "forma") enctype, html5Clone: ??"<: nav> </: nav>"!. == o.createElement ( "VL") cloneNode (0) .outerHTML, boxModel: "CSS1Compat" === o.compatMode, deleteExpando: 0, noCloneEvent: 0, inlineBlockNeedsLayout: 1, shrinkWrapBlocks: 1, reliableMarginRight: 0, boxSizingReliable: 0, pixelPosition: 1}, a. ! comprobado = 0, t.noCloneChecked = a.cloneNode .checked, s.disabled = 0, t.optDisabled = l.disabled (0);! try {eliminar d.test} catch (h) {t.deleteExpando =! 1} a = o.createElement ( "entrada"), a.setAttribute ( "valor", ""), t.input = "" === a.getAttribute ( "valor"), a.value =" t", a.setAttribute ( "tipo", "radio"), t.radioValue = "t" === a.value, a.setAttribute ( "verificado", "t"), a.setAttribute ( "nombre" , "t"), u = o.createDocumentFragment (), u.appendChild (a), t.appendChecked = a.checked, t.checkClone = u.cloneNode (0) .cloneNode (0) .lastChild.checked , d.attachEvent && (d.attachEvent ( "onclick", function () {t.noCloneEvent = 1!}), d.cloneNode (0) .click ()!), porque (f {a presentar: 0, el cambio : 0, focusIn: 0}) d.setAttribute (c = "on" + f, "t"), t [f + "burbujas"] = c en e || d.attributes [c] .expand O === 1;! (0) volver d.style.backgroundClip = "Content-box", d.cloneNode .style.backgroundClip = "", t.clearCloneStyle = "Content-box" === d.style .backgroundClip, b (function () {var n, r, a, s = "padding: 0; margin: 0; border: 0; display: block; caja de dimensionamiento: contenido de la caja; -moz-box-calibrado: contenido de la caja; -webkit-box-dimensionamiento: contenido de la caja;", u = o.getElementsByTagName ( "cuerpo") [0]; u && (n = o.createElement ( "div"), n.style.cssText = "border: 0; anchura: 0; altura: 0; position: absolute; top: 0; izquierda: -9999px; margin-top: 1px", u.appendChild (n) .appendChild (d), d.innerHTML =" <table> <tr> <td> </ td> <td> t </ td> </ tr> </ table>", a = d.getElementsByTagName ( "TD"), a [0] .style.cssText = "padding: 0; margin: 0; border: 0; display: none", p = 0 === a [0] .offsetHeight, a [0] .style.display = "", a [1] .style .La manifestación = "ninguna", t.reliableHiddenOffsets = p && 0 === a [0] .offsetHeight, d.innerHTML = "", d.style.cssText = "caja de dimensionamiento: frontera-box; -moz-box-dimensionamiento : frontera-box; -webkit-box-calibrado: frontera-box; padding: 1px; border: 1px; display: block; anchura: 4px; margin-top: 1%; position: absolute; top: 1%;", t.boxSizing = 4 === d.offsetWidth, t.does NotIncludeMarginInBodyOffset = 1! == u.offsetTop, e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (d, null) || {}). Top, t.boxSizingReliable = "4px" = == (e.getComputedStyle (d, null) || {width: "4px"}) ancho, r = d.appendChild (o.createElement ( "div")), r.style.cssText = d.style.. cssText = s, r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) {} || !) .marginRight)), typeof d.style.zoom == i && d.innerHTML = "", d.style.cssText = s + "anchura (: 1px; padding: 1px; display: inline; zoom: 1", t .inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = "bloque", d.innerHTML = "<div> </ div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (u.style.zoom = 1)), u.removeChild (n), n = d = a = r = null)}), n = s = u = l (?: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]); = r = a = null, t} () var O = / $ /, B = / ( [AZ]) / g; función P (e, n, r, i) {if (b.acceptData (e)) {var o, a, s = b.expando, u = "string" == typeof n, l = e.nodeType, p = l b.cache: e, f = l e [s]:?? e [s] && s; si (f && p [f] && (i || p [f] .data) | |! u || r == t) de retorno f || (? l e [s] = f = c.pop () || b.guid ++: f = S), p [f] || (p [f] = {}, l || (p [ f] .toJSON = b.noop)), ( "objeto" == typeof n || "función" == typeof n) && (i p [f] = b.extend (p [f], n)?: p [f] .data = b.extend (p [f] .data, n)), o = p [f], i || (o.data || (o.data = {}), o = O .data), r! == t && (O [b.camelCase (n)] = r), u? (a = O [n], null == a && (a = O [b.camelCase (n)]) ): a = O, a}} la función R (e, t, n) {if (b.acceptData (e)) {var r, i, o, a = e.nodeType, s = a b.cache?: e, u = a e [b.expando]:? b.expando; if (s [u]) {if (? t && (o = n s [u]: s [u] .data)) {b.isArray (t) t = t.concat (b.map (t, b.camelCase)):??? t en O t = [t] :( t = b.camelCase (t), t = t en O [t ]: t.split (" ")); for (r = 0, i = t.length; i> r; r ++) borrar o [t [r]]; if ((n $:!? b.isEmptyObject) (o)) return} (n || (s eliminar [u], $ .data (s [u]))) && (un b.cleanData ([e] ,! 0?): b.support.deleteExpando | !? | s = s.window eliminar s [u]: s [u] = null)}}} b.extend ({cache: {}, en Expansión: "jQuery" + (p + Math.random ()). sustituir (/ \ D / g, ""), nodata: {incrustar: 0, objeto: "CLSIDS D27CDB6E-AE6D-11cf-96B8-444553540000", subprograma: 0}, HasData: function (e) {return e = e.nodeType b.cache [e [b.expando]]:? e [b.expando], e !! && $ (e)}, los datos: la función (e, t, n) {ret urna P (e, t, n)}, REMOVEDATA: function (e, t) {return R (e, t)}, _ datos: function (e, t, n) {return P (e, t, n ,! 0)}, _ REMOVEDATA: function (e, t) {return R (e, t, 0)}, acceptData:!!! función (e) {if (e.nodeType && 1 == == e.nodeType && 9 e.nodeType) volver 1;! var t = e.nodeName && b.noData [e.nodeName.toLowerCase ()];! de retorno T || t == 0 && e.getAttribute ( "classid") === t}}), b!. fn.extend ({datos: function (e, n) {var r, i, o = esta [0], a = 0, s = null; si (e === t) {if (this.length && (s = b.data (o), 1 === o.nodeType && b._data (O "parsedAttrs"))) {for (r = o.attributes;! r.length> a; a ++) i = r [a ] .name, i.indexOf ( "datos -") || (i = b.camelCase (i.slice (5)), W (O, i, s [i])); b._data (o," parsedAttrs", 0)} return s} return! "objeto" == typeof e this.each (function () {b.data (esto, e)}):? b.access (esto, la función (n) {return n === t o W (O, e, b.data (O, e)):?? nula: (this.each (function () {b.data (esto, e, n)}), t) !}, null, n, arguments.length> 1, nULL, 0)}, REMOVEDATA: function (e) {return this.each (function () {b.removeData (esto, e)})}}); la función W (e, n, r) {if (r === t && 1 === e.nodeType) {var i = "datos -" + n.replace (B "- $ 1") toLowerCase ();. si ( r = e.getAttr ibute (i), "cadena" == typeof r) {try {r = "true" === r 0:?! "falsa" === R1:?!? "nulo" === r nulo: + r + "" === R + R:? O.test (r) b.parseJSON (r):? r} catch (o) {} b.data (e, n, r)} else r = t} r retorno de la función} $ (e) {var t; para (t en e) if (!!! ( "datos" == t || b.isEmptyObject (e [t])) && "toJSON" == t) volver 1; return 0} b.extend ({cola: función (e, n, r) {var i; e regreso (n = (n || "FX") + "cola", i = b!?. _data (e, n), r && (! i || b.isArray (r) i = b._data (e, n, b.makeArray (r)):? i.push (r)), i || [ ]): t}, quitar de la cola: la función (e, t) {t = t || "fx"; var n = b.queue (e, t), r = n.length, i = n.shift (), o = b._queueHooks (e, t), a = function () {b.dequeue (e, t)}; "inprogress" === i && (i = n.shift (), r -), o. act = i, i && ( "FX" === t && n.unshift ( "inprogress"), eliminar O.Stop, i.call (e, a, o)) ,! r && && o o.empty.fire ()}, _ queueHooks: función (e, t) {var n = t + "queueHooks"; b._data retorno (e, n) || b._data (e, n, {vacías:. b.Callbacks ( "una vez memoria") añadir (función () {b._removeData (e, t + "cola"), b._removeData (e, n)})})}}), b.fn.extend ({cola: function (e, n) {var r = 2; retorno "cadena" = typeof e && (n = e, e = "FX", r -), r> arguments.length b.queue (esto [0], e) = n === t?!? esto: this.ea ch (function () {var t = b.queue (esto, e, n); b._queueHooks (esto, e), "FX" === e && "inprogress" == t [0] && b.dequeue (! esto, e)})}, quitar de la cola: function (e) {return this.each (function () {b.dequeue (esto, e)})}, el retraso: function (e, t) {return e = b. ? fx b.fx.speeds [e] || e: e, t = t || "FX", this.queue (t, la función (t, n) {var r = setTimeout (t, e); n. detener = function () {clearTimeout (r)}})}, clearQueue: function (e) {return this.queue (e || "FX", [])}, promesa: function (e, n) {var r , i = 1, o = b.Deferred (), a = esta función, s = this.length, u = () {- i || o.resolveWith (a, [a])}; "cadena"! = typeof e && (n = e, e = t), e = e || "FX", mientras que (s -) r = b._data (a [s], e + "queueHooks"), r && r.empty && (i ++ , r.empty.add (u)); u (retorno), o.promise (n)}}); var I, z, X = / [\ t \ r \ n] / g, U = / \ r / g, V = / ^ (?: entrada | seleccione | textarea botón | | objeto) $ / i, Y = / ^ (?: a | área) $ / i, J = / ^ (?: comprobado | seleccionado | enfoque automático | reproducción automática | asíncrono | controles | aplazar | deshabilitado | escondido | bucle | múltiple | abierto | sólo lectura | requerida | scoped) $ / I, G = / ^ (?: comprobado | seleccionada) $ / I, Q = b.support .getSetAttribute, K = b.support.input; b.fn.extend ({attr: función (e, t) {b.access de retorno (esto, b.attr, e, t, argU ments.length> 1)}, removeAttr: function (e) {return this.each (function () {b.removeAttr (esto, e)})}, prop: function (e, t) {return b.access ( esto, b.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return e = b.propFix [e] || e, this.each (function () {try {esta [ e] = t, suprimir esta [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i, o, a = 0, s = this.length, u = "string" == typeof e && e; si (b.isFunction (e)) de regreso this.each (función de (t) {b (esto) .addClass (e.call (esto, t, this.className))}) ; si (u) para (t = (e || "") partido (w) || [];. s> a; a ++) si (n = esta [a], r = 1 === n.nodeType && (? n.className .replace ( " "+ n.className +" ") (X," "):" ")) {o = 0, mientras que (i = t [o ++]) 0> r.indexOf ("" + i + " ") && (r + = i +""); n.className = b.trim (r)} devuelva esta}, removeClass: function (e) {var t, n, r, i, o, a = 0 , s = this.length, u = 0 === arguments.length || "string" == typeof e && e; si (b.isFunction (e)) de regreso this.each (función de (t) {b (esto). removeClass (e.call (esto, t, this.className))}), si (u) para (t = (e || "") partido (w) || [];. s> a; a ++) si (? n = esta [a], r = 1 === n.nodeType && (( " "+ n.className +" ") .replace n.className (X," "):"")) {o = 0; mientras que (i = t [o ++]), mientras que (r.indexOf ( " "+ i +" ")> = 0) r = r.replace (" "+ i +""," ");? n.className = e b .trim (r): ""} devolver esta}, toggleClass: function (e, t) {var n = typeof e, r = "? boolean" == typeof t; volver b.isFunction (e) this.each ( función (n) {b (esto) .toggleClass (e.call (esto, n, this.className, t), t)}): this.each (function () {if ( "string" === n) {var o, a = 0, s = b (esto), u = t, l = e.match (w) || [], mientras que (O = l [a ++]) u = r U: s?!. hasClass (o), s [u "addClass": "removeClass"] (o)} else (n === i || "booleano" === n) && (this.className && b._data (esto "__ className__ ", this.className), this.className = this.className || e === 1!? "": b._data (esto " __ __ className") || "")})}, hasClass: function (e ) {var t = " "+ e +"", n = 0, r = this.length; para (; r> n; n ++) si (1 === esta [n] .nodeType && (" "+ esta [n ] .className + " ") .replace (X,"") .indexOf (t)> = 0) devuelven 0; volver 1}, val:! función (e) {var n, r, i, o = esta [ 0]; {if (arguments.length) de retorno i = b.isFunction (e), this.each (function (n) {var O, a = b (this); 1 === this.nodeType && (o = i ? e.call (esto, n, a.val ()): e, null == O o = "?": "número" == typeof o o + =? "": b.isArray (o) && (O = b.map (O, func ion (e) {return nula == e "?": e + ""})), r = b.valHooks [this.type] || b.valHooks [this.nodeName.toLowerCase ()], r && "set" en r && r.set (esto, oh, "valor") == || t (This.Value = O)));} if (o) de retorno R = b.valHooks [o.type] || b.valHooks [o.nodeName.toLowerCase ()], r && "obtener" en r && (n = r.get (o "valor")) == t n:? (n = o.value, "cadena" == typeof n n.replace (U ""): n == null? "?": n)}}}), b.extend ({valHooks: {opción: {get: function (e) {var t = e. !? attributes.value; return t || t.specified e.value: e.text}}, seleccione: {llegar: function (e) {var T, n, R = e.options, i = e.selectedIndex, o = "select-uno" === e.type || 0> i, a = o nulo:? [], s = o i + 1:? r.length, u = 0> i s:? o? i: 0; for (; s> u, u ++) si (n = r [u], (n.selected && u == i || (b.support.optDisabled n.disabled: null == n!!!?! .getAttribute ( "desactivado")) || n.parentNode.disabled && b.nodeName (n.parentNode, "optgroup"))) {if (t = b (n) .val (), o) de retorno t; a.push (t)} volver a}, sistema: función (e, t) {var n = b.makeArray (t); retorno b (e) .find ( "opción") cada uno (function () {this.selected =. b.inArray (b (esto) .val (), n)> = 0}), n.length || (e.selectedIndex = -1), n}}}, attr: function (e, n, r) {var o, a, s, u = e.nod eType; if (! e && 3 == u && 8 == u && 2 == u!!) volver typeof e.getAttribute === i b.prop (e, n, r) :( a = 1 == u ||?! b.isXMLDoc (e), a && (n = n.toLowerCase (), o = b.attrHooks [n] || (J.test (n) z:? I))?, r === t o && a && "conseguir "en O && nula == (s = o.get (e, n)) s:? (typeof e.getAttribute == i && (s = e.getAttribute (n)), == null s t:!? s) : nula == r o && && un "conjunto" en O && (s = o.set (e, r, n)) == t s:?!? (e.setAttribute (n, r + ""), r) :( b.removeAttr (e, n), t))}, removeAttr: function (e, t) {var n, r, i = 0, o = t && t.match (w), si (o && 1 === e.nodeType ), mientras que (n = o [i ++]) r = b.propFix [n] || n, J.test (n) ?! Q && G.test (n) e [b.camelCase ( "default -"? + n) ] = e [r] = 1: [R] e = 1: b.attr (e, n, ""), e.removeAttribute (Q n:? r)}, {attrHooks: tipo: {conjunto: función (e, t) {if (b.support.radioValue && "radio" === t && b.nodeName (e, "entrada")!) {var n = e.value; vuelva e.setAttribute ( "tipo", t ), n && (e.value = n), t}}}}, propFix: {tabindex: "tabIndex", sólo lectura: "readOnly", "para": "htmlFor", "clase": "className", maxlength: "maxLength", espaciado de celda: "cellSpacing", cellpadding: "cellPadding", rowspan: "rOWSPAN", colspan: "colspan", usemap: "usemap", frameborder: "frameBorder", contentedit capaz: "contentEditable"}, prop: function (e, n, r) {var i, o, a, s = e.nodeType; if (!!! e && 3 == s && 8 == s && 2 == s) volver a = 1! == s ||! b.isXMLDoc (e), a && (n = b.propFix [n] || n, o = b.propHooks [n]), r! == t? o && "conjunto" en ! O && (i = o.set (e, r, n)) == t I:? e [n] = r:! O && "obtener" en O && nula == (i = o.get (e, n)) ? i: e [n]}, propHooks: {tabIndex: {consigo: function (e) {var n = e.getAttributeNode ( "tabindex"); retorno n && n.specified parseInt (n.value, 10):? V. de prueba (e.nodeName) || Y.test (e.nodeName) && e.href 0:? t}}}}), z = {obtener: function (e, n) {var r = b.prop (e, n), i = "booleano" == typeof && r e.getAttribute (n), o = "booleano" == typeof r K && Q nula =? i:?!? G.test (n) e [b.camelCase ( "default - "+ n)]: i !!: e.getAttributeNode (n); return o && o.value == 1 n.toLowerCase (): t}, establezca: function (e, t, n) {return t!? !? === 1 b.removeAttr (e, n): K && || Q G.test (n) e.setAttribute (Q && b.propFix [n] || n, n!):? e [b.camelCase ( "default -" + n)] = e [n] = 0, n}}, K && || Q (b.attrHooks.value = {get: function (e, n) {var r = e.getAttributeNode (n) ??; volver b.nodeName (e, "entrada") e.defaultValue: r && r.specified r.value: t}, sistema: función (e, n, r) {return b.nodeName (e, "entrada") ? (e.defa ultValue = n, t): I && I.set (e, n, r)}}), Q || (I = b.valHooks.button = {obtener: function (e, n) {var r = e.getAttributeNode ( ?!? n); r volver && ( "ID" === n || "nombre" === n || "coordenadas" === n "" == r.value: r.specified) r.value: t}, sistema: función (e, n, r) {var i = e.getAttributeNode (r); retorno i || e.setAttributeNode (i = e.ownerDocument.createAttribute (r)), i.value = n + = "", "valor" === r || n === e.getAttribute (r) n:? t}}, b.attrHooks.contenteditable = {obtener: I.get, sistema: función (e, t, n) {I.set (e "" === t 1:?! t, n)}}, b.each ([ "ancho", "altura"], la función (e, n) {b.attrHooks [n] = b.extend (b.attrHooks [n], {set: function (e, r) {return "" === r (e.setAttribute (n,? "auto"), r): t} })})), b.support.hrefNormalized || (b.each ([ "href", "src", "ancho", "altura"], la función (e, n) {b.attrHooks [n] = b.extend (b.attrHooks [n], {conseguir: function (e) {var r = e.getAttribute (n, 2); retorno nulo == r t:? r}})}), b.each ( [ "href", "src"], la función (e, t) {b.propHooks [t] = {get: function (e) {return e.getAttribute (t, 4)}}})), b.support .style || (b.attrHooks.style = {get: function (e) {return e.style.cssText || t}, establezca: function (e, t) {return e.style.cssText = t + "" }}), B.support.optSelected || (b.propHooks.selected = b.extend (b.propHooks.selected, {get: function (e) {var t = e.parentNode; retorno t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null}})), b.support.enctype || (b.propFix.enctype = "codificación"), b.support.checkOn || b.each ([ "radio", "casilla de verificación"], function () {b.valHooks [esto] = {get: function (e) {return nula === e.getAttribute ( "valor") "en":? e.value}}}), b.each ([ "radio", "casilla de verificación"], la función () {b.valHooks [esta] = b.extend (b.valHooks [este], {set: función (e, n) {return b.isArray ? (n) = e.checked b.inArray (b (e) .val (), n)> = 0: t}})}); var = Z / ^ (entrada ?: | selecto | área de texto) $ / i, y = / ^ tecla /, tt = / ^ (ratón ?: | contextual) | pulse /, nt = / ^ (focusinfocus ?: | focusoutblur) $ /, tr = / ^ ([^.] *) ( ?: \ |) $ /; función de TI () {return 0} ot función () {return 1!} = {b.event mundial. (+.): {}, añadir: function (e, n, r , o, a) {var s, u, l, c, p, f, d, h, g, m, y, v = b._data (e), si (v) {r.handler && (c = r , r = c.handler, a = c.selector), r.guid || (r.guid = b.guid ++), (u = v.events) || (u = v.events = {}), ( f = v.handle) || (f = v.handle = function (e) {return typeof b === i || e && b.event .triggered === e.type t:?. b.event.dispatch.apply (f.elem, argumentos)}, f.elem = e), n = (n || "") partido (w) || [ ""], l = n.length; while (l -) s = rt.exec (n [l]) || [], G = Y = s [1], m = (s [2] | ..? | "".) dividido ( "") sort (), p = b.event.special [g] || {}, g = (a p.delegateType: p.bindType) || g, p = b.event.special [g] || {}, d = b.extend ({type: g, origType: y, los datos: o, handler: r, GUID: r.guid, selector: a, needsContext: a && b. expr.match.needsContext.test (a), espacio de nombres: m.join ( "")}, c), (h = u [g]) || (h = u [g] = [], h.delegateCount = 0, p.setup && p.setup.call (e, o, m, f) == 1 || (e.addEventListener e.addEventListener (g, f, 1):!!?! e.attachEvent && e.attachEvent (" en "+ g, f))), p.add && (p.add.call (e, d), d.handler.guid || (d.handler.guid = r.guid)), una? h.splice (h.delegateCount ++, 0, d):! h.push (d), b.event.global [g] = 0; e = null}}, remover: function (e, t, n, r, i) { var o, a, s, u, l, c, p, f, d, h, g, m = b.hasData (e) && b._data (e), si (m && (C = m.events)) { t = (t || "") partido (w) ||. [ ""], l = t.length; while (l -) si (s = rt.exec (t [l]) || [] , d = g = s [1], h = (s [2] || ""). split ( ""). sort (), d) {p = b.event.special [d] || { }, d = (r p.delegateType:? p.bindType) || d, f = c [d] || [], s = s [2] && RegExp (| + h.join ( "\\ ( "(^ \\).": \\ *.?.. .! |) ") +" (\\ | $) "), u = o = f.length, mientras que (O -) a = f [o] ,! i && g == a.origType || n && n.guid ! == a.guid || s &&! s.test (a.namespace) || r && r! == a.selector && ( "**"! == r ||! a.selector) || (f.splice ( O, 1), a.selector && f.delegateCount -, p.remove && p.remove.call (e, a)); u && && f.length (p.teardown && p.teardown.call (e, h, m.handle)! ==! 1 || b.removeEvent (e, d, m.handle), borrar c [d])} else para (d en c) b.event.remove (e, d + t [L], n, ! r, 0); b.isEmptyObject (c) && (borrar m.handle, b._removeData (e, "eventos"))}}, disparador: function (n, r, i, a) {var s, u , l, c, p, f, d, h = [i || o], g = y.call (n, "tipo") n.type:? n, m = y.call (n, "espacio de nombres" ) n.namespace.split ()? "":!!! []; si (l = f = i = i || O, 3 == i.nodeType && 8 == i.nodeType && nt.test (g + b .event.triggered) && (g.indexOf ( " ")> = 0 && (m = g.split ("."), g = m.shift (), m.sort ()), u = 0> g .indexOf ( ":") && "on" + g, n = n [b.expando] n:? nuevo b.Event (g, "objeto" == typeof n && n), n.isTrigger = 0, n!. namespace = m.join ( " "), n.namespace_re = n.namespace RegExp ("(^ | \\). "+ m.join (" \\ (:.?.. * \\ |)"? ) + "(\\ | $)."):? nula, n.result = t, n.target || (n.target = i), r = null == r [n]: b.makeArray (r , [n]), p = b.event.speci al [g] || {}, a ||! p.trigger || p.trigger.apply (i, r)! ==! 1)) {if (! a &&! p.noBubble &&! b.isWindow (i )) {for (c = p.delegateType || g, nt.test (c + g) || (l = l.parentNode); l; l = l.parentNode) h.push (l), f = l ; f === (i.ownerDocument || o) && h.push (f.defaultView || f.parentWindow || e)} d = 0;! mientras que ((L = h [d ++]) && n.isPropagationStopped ( )) n.type = d> 1 c:? p.bindType || g, s = (b._data (l, "eventos") || {}) [n.type] && b._data (l, "manija "), s && s.apply (l, r), s = u && l [u], s && b.acceptData (l) && s.apply && s.apply (l, r) === 1 && n.preventDefault (); if (! n.type = g,! (a || n.isDefaultPrevented () || p._default && p._default.apply (i.ownerDocument, r)! ==! 1 || "clic" === g && b.nodeName (i, "una ") ||! b.acceptData (i) ||! u ||! i [g] || b.isWindow (i))) {f = i [u], f && (i [u] = null), b.event.triggered = g; try {i [g] ()} catch (v) {} b.event.triggered = t, f && (i [u] = f)} return n.result}}, de expedición: función (e) {e = b.event.fix (e); var n, r, i, o, a, s = [], u = h.call (argumentos), l = (b._data (esto, "eventos") || {}) [e.type] || [], c = b.event.special [e.type] || {}; si (u [0] = e, e.delegateTarget = esta ,! c.preDispatch || c.preDispatch.call (esto, e)! ==! 1) {s = b.event.handler s.call (esto, e, l), n = 0; while ((O = s [n ++]) && e.isPropagationStopped ()!) {e.currentTarget = o.elem, a = 0; while ((i = o.handlers [a ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((b.event.special [i.origType] || {}). || manejar i.handler) .apply (o.elem, u), r! == t && (e.result = r) = == 1 && (e.preventDefault (), e.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (esto, e), e.result}}, manipuladores: función (e, n) {var r , i, o, a, s = [], u = n.delegateCount, l = e.target; if (! u && && l.nodeType (e.button || "clic" == e.type)!) para (; l = presente;! l = || l.parentNode esto) if (!!! 1 === l.nodeType && (l.disabled == 0 || "clic" == e.type)) {for (o = [], a = 0; u> a;? a ++) i = n [a], r = i.selector +"", o [r] === t && (o [r] = i.needsContext b (r, esto) .index (l)> = 0: b.find (r, este, null, [l]) de longitud), o [r] && o.push (i); o.length && s.push ({elem:. l , manipuladores: o})} return n.length> u && s.push ({elem: esto, los manipuladores: n.slice (u)}), s}, fijar: function (e) {if (e [b.expando] ) de retorno e; var t, n, r, i = e.type, a = e, s = this.fixHooks [i]; s || (this.fixHooks [i] = s = tt ? .test (i) this.mouseHooks:? Et.test (i) this.keyHooks: {}), r = s.props this.props.concat (s.props):? This.props, e = new b .Los (a), t = r.length; while (t -) n = r [t], e [n] = a [n]; volver e.target || (e.target = a.srcElement | | O), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !! e.metaKey, s.filter s.filter (e, a): e}? , apoyos: "altKey burbujas cancelable ctrlKey currentTarget eventPhase metakey relatedTarget shiftKey vista timeStamp diana que" .split ( " "), fixHooks: {}, keyHooks: {apoyos:" char charCode keyCode clave" .split (" "), filtro: función (e, t) {return null == e.which && (e.which = null = t.charCode t.charCode:!? t.keyCode), e}}, mouseHooks: {apoyos: "botones botón clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), filtro: función (e, n) {var r, i, a, s = n.button, u = n.fromElement; retorno nulo == e.pageX && nula ! = n.clientX && (i = e.target.ownerDocument || O, a = i.documentElement, r = i.body, e.pageX = n.clientX + (a && && a.scrollLeft || r || r.scrollLeft 0) - (a && a.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (a & Y a.scrollTop || r && r.scrollTop || 0) - (a && a.clientTop || r && r.clientTop || 0)) ,! e.relatedTarget && u && (e.relatedTarget = u === e.target?n.toElement:u ), e.which || s === t || (e.which = 1 & s 1: 2 y 3 s: 4 y 2 s:? 0), e}}, {especiales: carga: {noBubble: 0}, haga clic en: {gatillo: function () {return b.nodeName (esto "entrada") && "casilla de verificación" === this.type && this.click (this.click () ,! 1):? t}}, el enfoque: {gatillo: function () {if (esto == o.activeElement && this.focus!) {return tratar this.focus () ,! 1} catch (e) {}}, delegateType: "focusin"}, falta de definición: {gatillo : function () {return esta === o.activeElement && this.blur (this.blur () ,! 1):? t}, delegateType: "focusOut"}, beforeunload: {postDispatch: function (e) {e.result ! == t && (e.originalEvent.returnValue = e.result)}}}, simular: function (e, t, n, r) {var i = b.extend (nuevo b.Event, n, {type: e , isSimulated: 0, originalEvent: {}}); r b.event.trigger (i, null, t): b.event.dispatch.call (t, i), i.isDefaultPrevented () && n.preventDefault ( )}}, b.removeEvent = o.removeEventListener función (e, t, n) {e.removeEventListener && e.removeEventListener (t, n, 1)}:?! función (e, t, n) {var r = "on "+ t; e.de tachEvent && (typeof e [r] === i && (e [r] = null), e.detachEvent (r, n))}, b.Event = función (e, n) {return este instanceof b.Event? ( e && e.type (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || 1 || e.returnValue === e.getPreventDefault && e.getPreventDefault () es:!? OT)? : this.type = e, n && b.extend (esto, n), this.timeStamp = e && e.timeStamp || b.now (), esta [b.expando] = 0, t): nueva b.Event (e , n)}, b.Event.prototype = {isDefaultPrevented: ot, isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault:? function () {var e = this.originalEvent; this.isDefaultPrevented = ella, e && (e.preventDefault e ! .preventDefault (): e.returnValue = 1)}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = ella, e && (e.stopPropagation && e.stopPropagation (), e.cancelBubble = 0) }, stopImmediatePropagation: function () {this.isImmediatePropagationStopped = it, this.stopPropagation ()}}, b.each ({MouseEnter: "mouseover", mouseleave: "mouseout"}, la función (e, t) {b.event .Special [e] = {delegateType: t, bindType: t, manejar: function (e) {Var n, r = este, i = e.relatedTarget, o = e.handleObj;
retorno (! i || i! == r &&! b.contains (r, i)) && (e.type = o.origType, n = o.handler.apply (esto, argumentos), e.type = t) , n}}}), b.support.submitBubbles || (b.event.special.submit = {configuración: function () {return b.nodeName (esto, "forma") ?! 1: (b.event. añadir (esto "click._submit keypress._submit", la función (e) {var n = e.target, r = b.nodeName (n, "entrada") || b.nodeName (n, "botón")? n.form:! t; r && b._data (r, "submitBubbles") && (b.event.add (r, "submit._submit", la función (e) {e._submit_bubble = 0!}), b. _data (r, "submitBubbles", 0))}), t)}, postDispatch: function (e) {e._submit_bubble && (eliminar e._submit_bubble, this.parentNode &&! E.isTrigger && b.event.simulate ( "submit", this.parentNode, e, 0))}, desmontaje: function () {return b.nodeName (esto, "forma") ?! 1: (b.event .Remove (esto "._ submit"), t)}}), b.support.changeBubbles || (b.event.special.change = {configuración: function () {return Z.test (this.nodeName)? (( "casilla de verificación" === this.type || "radio" === this.type) && (b.event.add (esto "propertychange._change", la función (e) { "marcada" === e.originalEvent.propertyName && (this._just_changed = 0)}), b.event.add (esto "click._change", la función (e) {this._just_changed &&! e.isTrigger && (this._just_changed =! 1) , b.event.simulate ( "cambio", esto, e, 0)})) ,! 1) :( b.event.add (esto "beforeactivate._change", la función (e) {var t = e .target;! Z.test (t.nodeName) && b._data (t, "changeBubbles") && (b.event.add (t, "change._change", la función (e) {this.parentNode || e.isSimulated || || e.isTrigger b.event.simulate ( "cambio", this.parentNode, e, 0)}), b._data (t, "changeBubbles", 0))}), t )}, manejar:!!! función (e) {var n = e.target; devuelva esta == || n || e.isSimulated e.isTrigger || "radio" == n.type && "casilla de verificación" == n.type? e.handleObj.hand (ler.apply esto, argumentos): t}, desmontaje: function () {b.event.remove retorno (esto "._ cambio") ,! Z.test (this.nodeName)}}), b.support. focusinBubbles || b.each ({foco: "focusIn", falta de definición: "focusOut"}, la función (e, t) {var n = 0, r = function (e) {b.event.simulate (t, e. objetivo, b.event.fix (e) ,! 0)}; b.event.special [t] = {configuración: function () {0 === n ++ && o.addEventListener (e, r, 0) }, desmontaje: function () {0 === - n && o.removeEventListener (e, r, 0)}}}), b.fn.extend ({on: function (e, n, r, i, o ) {var a, s; if (! "objeto" == typeof e) { "string" = typeof n && (r = r || n, n = t); para (a this.on en e) (a, n, r, e [a], o); devuelva esta} Si (null == r && nula == i (i = n, r = n = t?): == null i && ( "string" == typeof n? (i = r, r = t) :( i = r, r = n, n = t)), i === 1) i = ot;! else if (i) Retorno este; volver 1 === o && (s = i, i = función (e) {return b (). off (e), s.apply (esto, argumentos)}, i.guid = s.guid || (s.guid = b.guid ++ )), this.each (function () {b.event.add (esto, e, i, r, n)})}, uno: function (e, t, n, r) {return this.on (e , t, n, r, 1)}, off: function (e, n, r) {var i, o, si (e && e.preventDefault && e.handleObj) retorno i = e.handleObj, b (e.delegateTarget) .OFF (i.namespace? i. origType + + i.namespace " ": i.origType, i.selector, i.handler), esto, si (" objeto" == typeof e) {for (o en e) this.off (O, N, E [o]); devolver esta} retorno (n === 1 || "función" == typeof n) && (r = n, n = t), r === 1 && (r = OT), este! each (function () {b.event.remove (esto, e, r, n)})}, se unen: function (e, t, n) {return this.on (e, null, t, n)} , desenlazar: function (e, t) {return this.off (e, null, t)}, delegado: function (e, t, n, r) {return this.on (t, e, n, r)} , undelegate: function (e, t, n) {return 1 === arguments.length this.off (e, "**"):? this.off (t, e || "**", n)} , disparador: function (e, t) {return this.each (function () {b.event.trigger (e, t, esto)})}, triggerHandler: function (e, n) {var r = esta [0 ?]; r retorno b.event.trigger (! e, n, r, 0): t}}), función (e, t) {var n, r, i, o, a, s, u, l, c, p, f, d, h, g, m, y, v, x = "chisporroteo" + - nuevos Fecha, w = e.document, T = {}, N = 0, C = 0, k = it (), E = it (), S = que (), A = typeof t, j = 1 << 31, D = [], L = D.pop, H = D.push, q = D.slice, M = D.indexOf función || (e) {var t = 0, n = this.length; para (; n> t; t ++) si (esta [t] === e) retorno t; volver-1} ?., _ = "[\\ x20 \\ t \\ r \\ n \\ f]", F = "(: \\\\ | [\\ w-] | [^ \\ x00 - \\ xa0]) + "O = F.replace ( "w", "w #"), B =" ( [* ^ $ |! ~] =) "P = "\\ [" + _ + "* (" + F + ")" + _ + "* (?:" + B + _ +" * (?? : ([ '\ "]) ((:?.? \\\\ | [^ \\\\]) *) \\ 3 | (" + O + ") |) |)" + _ + "* \ \]", R = ":(" + F + ") (: \\ ((([ '\"]) ((?:?.? \\\\ | [^ \\\\]) *) \ \ 3 | ((:?. \\\\ | [^ \\\\ () [\\]] | "+ P.replace (3,8) +") *) | *) \\) |. )", W = RegExp ( "^" + _ + "+ | ((?:?. ^ | [^ \\\\]) (: \\\\) *)" + _ + "+ $", "g"), $ = RegExp ( "^" + _ + "*" + _ + "*"), I = RegExp ( "^" + _ + "* ([\\ x20 \\ t \\ r \\ n \\ f> + ~]) "+ _ +" * "), z = RegExp (R), X = RegExp (" ^ "+ O +" $ "), U = {ID: RegExp (" ^ # ( "+ F +") "), CLASE: RegExp (". ^ \\ ( "+ F +") "), nOMBRE: RegExp (" "?] (" ^ \\ [nombre = [ '\ + F +" ) [ '\ "] \\]?"), TAG: RegExp ( "^ (" + F.replace ( "w", "w *") + ")"), ATTR: RegExp ( "^" + P ), PSEUDO: RegExp ( "^" + R), nIÑO: RegExp ( "^ :( única | primero | último | enésima | nth-last) - (niño | de tipo) (: \\ (?" + _ + "* (aun | extraña | (([+ -] |) (d \\ *) n |)" + _ + "* (?: ([+ -] |)" + _ + "* (\\ d +) |)) "+ _ +" * \\) |) " "i"), needsContext: RegExp ( "^" + _ +" * [> + ~] |: (aun | extraña | eq | gt | lt | enésima | primero | pasada) (: \\ ( "+ _ +" * ((: -??? \\ d) \\ * d) "+ _ +" * \\) |?) (= [^ -] | $)", "i")}, V = / [\ x20 \ t \ r \ n \ F] * [+ ~] /, Y = / ^ [^ {] + \ {\ s * \ [código nativo /, J = / ^ (?:. # ([\ w -] +) | (\ w +) | \ ([\ w -] +)) $ /, G = / ^ (?: de entrada | seleccione | textarea botón |) $ / i, Q = / ^ h \ d $ / i, K = / '| \\ / g, Z = / \ = [\ x20 \ t \ r \ N \ f] * ([^ ' "\]] *) [\ x20 \ t \ r \ n \ f] * \] / g, et = / \\ ([\ da-fA-F] {1 t retorno n == n;) / g, tt = función (e, t) {var n = "0x" + t-65536 |, 6} [\ x20 \ t \ r \ n \ f]?.? : 0> n (n + String.fromCharCode 65536):? String.fromCharCode (55296 | n >> 10,56320 | 1023 y n)}; try {q.call (w.documentElement.childNodes, 0) [0] .nodeType } catch (nt) {q = function (e) {var t, n = []; while (t = esta [e ++]) n.push (t); retorno n}} function rt (e) {Y. retorno ensayo (e + "")} función de TI () {var e, t = []; retorno e = función (n, r) {return t.push (n + =" ")> i.cacheLength && eliminar e [t.shift ( )], e [n] = r}} función ot (e) {return e [x] = 0 e función,} en (e) {var t = p.createElement ( "div");! try {retorno e (t)} catch (n) {return! 1} finally {t = null}} function st (e, t, n, r) {var i, o, a, s, u, l, f, g, m , v; if ((t t.ownerDocument || t:?! w) == p && c (t), t = t || p, n = n || [] ,! e || "string" = typeof e) retorno n;! if (! 1 == (s = t.nodeType) && 9 == s) volver []; if (!! d && r) {if (i = J.exec (e)) si (a = i [1]) {if (9 === s) {if (o = t.getElementById (a) ,! o || o.parentNode) de retorno n; if (! o.id === a) de retorno n.push (o), n} else if (t.ownerDocument && (o = t.ownerDocument.getElementById (a)) && y (t, o) && o.id === a) de retorno n. push (o), n} else {if (i [2]) vuelva H.apply (n, q.call (t.getElementsByTagName (e), 0)), n; if ((a = i [3]) && T.getByClassName && t.getElementsByClassName) de regreso H.apply (n, q.call (t.getElementsByClassName (a), 0)), n} Si (T.qsa &&! h.test (e)) {if (f = 0 , G = x, m = t, v = 9 === s && e, 1 === s && "objeto"! == t.nodeName.toLowerCase ()) {l = ft (e), (f = t.getAttribute ? ( ??"id")) g = f.replace (K, "\\ $ &"): t.setAttribute ( "id", g), g = "[id = ' "+ g +"']", u = l.length; while (u -) l [u] = g + dt (l [U]); m = V.test (e) && t.parentNode || t, v = l.join ( "" )} if (v) tratar {return H.apply (n, q.call (m.querySelectorAll (v), 0)), n} catch (b) {} finally {f || t.removeAttribute ( "id" )}}} retorno en peso (e.replace (W, "$ 1"), t, n, r)} a = st.isXML = function (e) {var t = e && (e.ownerDocument || e) .documentElement ; "HTML" retorno t == t.nodeName: 1}, c = st.setDocument = function (e) {var n = e e.ownerDocument || e:?!?! w; volver n == p && 9 = == n.nodeType && n.documentElement? (p = n, f = n.documentElement, d = a (n), T.tagNameNoComments = a (function (e) {return e.appendChild (n.createComment ( "")) ,! e.getElementsByTagName ( "*"). longitud}), T.attributes = a (function (e) {= e.innerHTML "<Select> </ select>"; var t = typeof e.lastChild.getAttribute ( "múltiple");! Retorno "booleano" == t && "cadena" == t}), T.getByClassName = a (función (e) {return e.innerHTML = "<div class = 'oculto e'> </ div> <div class = 'oculto'> </ div>", e.getElementsByClassName && e.getElementsByClassName ( "e"). longitud? (e.lastChild.className = "e", 2 === e.getElementsByClassName ( "e"). longitud) :! 1}), T.getByName = a (function (e) {e.id = x + 0 , e.innerHTML = "name='"+x+"'> </a> <div name = <a ' "+ x +"'> </ div>", f.insertBefore (e, f.firstChild); var t = n.getElementsByName && n.getElementsByName (x) .length === 2 + n.getElementsByName (x + 0) .length;! volver T.getIdNotName = n.getElementById (x), f.removeChild (e), t} ), i.attrHandle = a (function (e) {return e.innerHTML = "<a href='#'> </a>", e.firstChild && typeof e.firstChild.getAttribute! == Un && "#" == = e.firstChild.getAttribute ( "href")}) {}: {href: function (e) {return e.getAttribute ( "href", 2)}, tipo: function (e) {return e.getAttribute ( "tipo")}}, T.getIdNotName (i.find.ID = función (e, t) {if (typeof t.getElementById == A && d!) {var n = t.getElementById (e);? r eturn n && n.parentNode [n]:? []}}, i.filter.ID = function (e) {var t = e.replace (et, tt); función de retorno (e) {return e.getAttribute ( "id ") === t}}) :( i.find.ID = función (e, n) {if (typeof n.getElementById == A && d) {var r = n.getElementById (e);! retorno r ? r.id === e || typeof r.getAttributeNode == Un && r.getAttributeNode ( "id") === valor de e [r]:.? t: []}}, i.filter.ID = function (e) {var t = e.replace (et, tt);! función de retorno (e) {var n = typeof e.getAttributeNode == A && e.getAttributeNode ( "id"); retorno n && n.value === t} ?}), i.find.TAG = T.tagNameNoComments función (e, n) {return typeof n.getElementsByTagName == Un n.getElementsByTagName (e):? t}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e), si ( "*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n) ; función, i.find.NAME = T.getByName && (e, n) de retorno r} return o} {return typeof n.getElementsByName == Un n.getElementsByName (nombre): t}, i.find.CLASS = T!? .getByClassName función && (e, n) {return typeof n.getElementsByClassName === A || d t:? n.getElementsByClassName (e)}, g = [], h = [ ": enfoque"], (T.qsa = rt (n.querySelectorAll)) && (al (functi en (e) {e.innerHTML = "<seleccionar> <opción seleccionada = ''> </ option> </ select>", e.querySelectorAll ( "[seleccionado]"). longitud || h.push ( "\ \ [ "+ _ +" * (?: comprobado | discapacitados | ismap | múltiple | sólo lectura | seleccionada | valor) "), e.querySelectorAll (": verificado ") || longitud h.push (": comprueba ") }), en (function (e) {e.innerHTML = "<input type = 'oculta' i = '' />", e.querySelectorAll ( "[i ^ = '']"). longitud && h.push (" [* ^ $] = "+ _ +" *: | "), e.querySelectorAll (" (\ "\" ''?): habilitado ") || longitud h.push (": habilitado "": desactivado "), e.querySelectorAll (" * ,: x "), h.push (", *:. ")})), (T.matchesSelector = rt (m = f.matchesSelector || f.mozMatchesSelector || f.webkitMatchesSelector || || f.oMatchesSelector f.msMatchesSelector)) && en (function (e) {T.disconnectedMatch = m.call (e, "div"),! m.call (e, "[s = '' ]:! x "), g.push (" =", R)}), h = RegExp (h.join ( "|")), g = RegExp (g.join ( "|")), y = ? rt (f.contains) || función f.compareDocumentPosition (e, t) {var n = 9 === e.nodeType e.documentElement:? e, r = t && t.parentNode; retorno e === r || ! (r || 1 || == r.nodeType (n.contains n.contains (r):!!!? e.compareDocumentPosition && 16 y e.compareDocumentPosition (r)))}: función (e, t) {if (t) tiempo (t = t.parentNode) si (t === e) return 0;! volver 1}?, v = f.compareDocumentPosition función (e, t) {var r;??? vuelta de correo === t (! u = 0,0) :( r = t.compareDocumentPosition && && e.compareDocumentPosition e.compareDocumentPosition (t)) 1 & r || e.parentNode && 11 === e.parentNode.nodeType e = == n || y (w, e) - 1:???? t === n || y (w, t) 1: 0: 4 & r -1: 1: e.compareDocumentPosition -1: 1}: función (e, t) {var, r, i = 0, o = e.parentNode, a = t.parentNode, s = [e] l = [t]; si (e === t) de retorno u =! (! O || a)?; 0,0 si el retorno de correo === n -1: t === n 1: o -1: 1:??? 0; si (O === a) r = e;; ut (e, t) devolver tiempo (r = r.parentNode) s.unshift (r); r = t; mientras que (r = r.parentNode) l.unshift (r), mientras (s [ i] === l [i]) i ++; retorno i ut (s [i], l [i]):??? s [i] === w -1: l [i] === w 1 : 0}, u = 1, [0,0] .Sort (v), T.detectDuplicates = u, p): p}, st.matches = function (e, t) {return st (e, null, nula, t)}, st.matchesSelector = function (e, t) {if ((e.ownerDocument || e)! == p && c (e), t = t.replace (Z "= '$ 1']" ! (! T.matchesSelector || d || g && g.test (t)), || h.test (t))) try {var n = m.call (e, t); si (n || T. disconnectedMatch || e.document && 11! == e.document.nodeType) de retorno n} catch (r) {} RETUR n st (t, p, null, [e]). longitud> 0}, st.contains = función (e, t) {return (e.ownerDocument || e)! == p && c (e), y (e , t)}, st.attr = función (e, t) {var n;! retorno (e.ownerDocument || e) == p && c (e), d || (t = t.toLowerCase ()), ( n = i.attrHandle [t]) n (e): d || T.attributes e.getAttribute (t):? ((n = e.getAttributeNode (t))? || e.getAttribute (t)) && e [t] === 0 t:!? n && n.specified n.value: null}, st.error = function (e) {error tiro ( "error de sintaxis, expresión no reconocida:" + e)}, st.uniqueSort = function (e) {var t, n = [], r = 1, i = 0; si (u = T.detectDuplicates, e.sort (v), u!) {for (; t = e [r] ; r ++) t === e [r-1] && (i = n.push (r)), mientras que (i -) e.splice (n [i], 1)} de retorno e}; función ut ( e, t) {var n = t && e, r = n && (~ t.sourceIndex || j) - (~ e.sourceIndex || j), si (r) de retorno r; si (n), mientras que (n = n. nextSibling) si (n === t) volver-1; e volver 1:? -1} function lt (e) {función de retorno (t) {var n = t.nodeName.toLowerCase (); return "de entrada" = == n && Ttipo === e}} ct función (e) {función de retorno (t) {var n = t.nodeName.toLowerCase (); (=== n || "botón" "de entrada" retorno == = n) && Ttipo === e}} pt función (e) {return ot (función de (t) {return t = + t, ot (función (n, r) {var i, o = e ([], n.length, t), a = o.length;! mientras que (a -) n [i = o [a]] && (n [i] = (r [i] = n [i]))})})} o = st.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; si (i) {if (1 = == i || 9 === i || 11 === i) {if ( "string" == typeof e.textContent) regrese e.textContent; para (e = e.firstChild; e; e = e. nextSibling) n + = o (e)} else if (3 === i || 4 === i) e.nodeValue} else regreso para (; t = e [r]; r ++) n + = o (t); retorno n}, i = st.selectors = {cacheLength: 50, createPseudo: OT, partido: T, encontrar: {}, relativa: { ">": {dir: "parentNode", en primer lugar: 0} "," : {dir: "parentNode"} "+": {dir: "previousSibling", en primer lugar: 0}, "~": {dir: "previousSibling"}}, prefiltro: {ATTR: function (e) {return e [1] = e [1] .replace (et, tt), e [3] = (e [4] || e [5] || ""). sustituir (et, tt), "~ =" === e [2] && (e [3] = " "+ e [3] +""), e.slice (0,4)}, NIÑO: function (e) {return e [1] = e [1] .tolowercase (), === e [1] .slice "nth" (0,3)? (e [3] || st.error (e [0]), e [4] = + ( ? e [4] e [5] + (e [6] || 1): 2 * ( "par" === e [3] || "impar" === e [3])), e [ 5] = + (e [7] + e [8] || "impar" === e [3])): e [3] && st.error (e [0]), e}, PSEUDO: function ( ?!? e) {var t, n = e [5] && e [2]; volver U.CHILD.test (e [0]) null: (e [4] e [2] = e [4]: ??n && z .test (n) && (t = ft (n ,! 0)) && (t = n.indexOf ( ")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG: function (e) {return "*" === e function () {return 0?!}: (e = e.replace (et, tt) .tolowercase (), la función (t) {return t.nodeName && t.nodeName.toLowerCase () === e})}, CLASE: function (e) {var t = k [e + " "]; de retorno T || (t = RegExp ("(^ | "+ _ +") "+ e +"( "+ _ +" | $)")) && k (e, la función (e) { volver t.test (e.className || typeof e.getAttribute == Un && e.getAttribute ( "clase") || ""!)})}, ATTR: function (e, t, n) {función de retorno (r) {var i = st.attr (r, e); return null == i === t? "=":? t (i + = "", "=" === t i === n:? "! =" === == t i n:?! "^ =" t N === === 0 && i.indexOf (n):? "* =" === t N && i.indexOf (n)? > -1:? "$ =" === T N && i.slice (-n.length) === n: "~ =" === t ( " "+ i +"") .indexOf (n)>? ? -1: "| =" === t i === n || i.slice (0, n.length + 1) === n + "-" :! 1) :! 0}}, NIÑO: función (e, t, n, r, i) {var o = "enésimo"! == e.slice (0,3), a = "último"! == e.slice (-4), s =" de tipo "=== t; RETURN 1 === r && 0 === i función (e) {return !! e.parentNode}: función (t, n, u) {var l, c, p, f? , d, h, g = o == un "nextSibling":!? "previousSibling", m = t.parentNode, y = s && t.nodeName.toLowe rCase (), v = u && s;! if (! m) {if (o) {while (g) {p = t;? while (p = p [g]) si (s p.nodeName.toLowerCase () === y: 1 === p.nodeType) RETURN 1; h = g = "sólo" === e && h && "nextSibling"} return 0} if (h = [a m.firstChild:!!!? m .lastChild], a && v) {C = m [x] || (m [x] = {}), L = c [e] || [], d = l [0] === N && l [1], f = l [0] === N && l [2], p = d && m.childNodes [d]; while (p = ++ d && p && p [g] || (f = d = 0) || h.pop ()) si (1 === p.nodeType && ++ f && p === t) {c [e] = [N, d, f]; descanso}} else if (v && (l = (t [x] || (t [x] = {})) [e]) && l [0] === N) f = l [1]; cosa mientras (p = ++ d && p && p [g] || (f = d = 0) || h.pop ()) si ((s p.nodeName.toLowerCase () === y:? 1 === p.nodeType) && ++ f && (v && ((p [x] || (p [x] = {})) [e] = [N, f]), p === t)) break; volver f- = i, f === r || 0 === f% r && f / r> = 0 }}}, PSEUDO: function (e, t) {var n, r = i.pseudos [e] || i.setFilters [e.toLowerCase ()] || st.error ( "pseudo no soportada:" + e) ; retorno r [x] r (t):??? r.length> 1 (n = [e, e, "", t], i.setFilters.hasOwnProperty (e.toLowerCase ()) ot (función (e , n) {var i, o = r (e, t), a = o.length, mientras que (a -) i = M.call (e, o [a]), e [i] = (n! [i] = O [a])}): function (e) {return r (e, 0, n)}): r}}, pseudos: {no: OT (function (e) {var t = [] , n = [], R = s (e.replace (W, "$ 1")); regreso ? R ot (función [x] (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length; while (s -) (o = una [s]) && (e [s] = (t [s] = o!))}): function (e, i, o) {return t [0] = e, r (t, nula, o, n) ,! n.pop ()}}), tiene: OT (function (e) {función de retorno (t) {return st (e, t) .length> 0}}), contiene: OT (función (e ) {función de retorno (t) {return (t.textContent || || t.innerText o (t)) indexOf (e)> - 1}.}), lang: OT (function (e) {return X.test (e || "") || st.error ( "no soportado lang:" + e), e = e.replace (et, tt) .tolowercase (), la función (t) {var n; hacer si (n = ? d t.getAttribute ( "xml: lang") || t.getAttribute ( "lang"): t.lang) de retorno n = n.toLowerCase (), n === e || 0 === n.indexOf (e + "-"), mientras que ((t = t.parentNode) && 1 === t.nodeType); regreso 1}}), objetivo: function (t) {var n = e.location && e.location.hash;! volver n && n.slice (1) === t.id}, raíz: function (e) {return e === f}, el enfoque: la función (e) {return e === p.activeElement && (p.hasFocus || p.hasFocus ()) && !! (e.type || || ~ e.href e.tabIndex)}, habilitado: function (e) {return e.disabled === 1}, personas con discapacidad: la función (e) {return e.disabled === 0}, comprobado: function (e) {var t = e.nodeName.toLowerCase (); return "entrada" === t && E.checked !! || "opción" === t && !! e.selected}, seleccionada: function (e) {return e.parentNode && e.parentNode.selectedIndex, e.selected === 0}, vacío: la función (e) {for (e = e.firstChild; e; e = e.nextSibling) si (e.nodeName> "@" || 3 || e.nodeType === === 4 e.nodeType) volver! 1; return 0}, padre:!! función (e) {return i.pseudos.empty (e)}, encabezado: function (e) {return Q.test (e.nodeName)}, de entrada: function (e) {return G.test (e.nodeName)}, botón: function (e) {var t = e.nodeName.toLowerCase (); retorno "botón" "de entrada" === t && === e.type ||" botón "=== t}, texto: function (e) {var t; retorno" de entrada "=== e.nodeName.toLowerCase () &&" texto "=== e.type && (null == (t = e .getAttribute ( "tipo")) || t.toLowerCase () === e.type)}, primero: pt (function () {return [0]}), última: pt (función (e, t) { volver [t-1]}), eq: pt (función (e, t, n) {return [0> n n + t:? n]}), incluso: pt (función (e, t) {var n = 0; para (; t> n; n + = 2) e.push (n); retorno e}), impar: pt (función (e, t) {var n = 1; para (; t> n; n + = 2) e.push (n); retorno e}), LT: pt (función (e, t, n) {var r = 0> n n + t:? n; para (; - r> = 0 ;) e.push (r); retorno e}), GT: pt (función (e, t, n) {var r = 0> n n + t:? n; for (; t> ++ r;) e.pus h (r); retorno e})}}; for (n {en la radio:!!!!! 0, casilla: 0, archivo: 0, contraseña: 0, imagen: 0}) i.pseudos [n] = lt (n); for (n en {! presentar: 0, reset: 0}) i.pseudos [n] = ct (n); función ft (e, t) {var n, r, o, a, s, u, l, c = e [e +" "]; si (c) retorno t 0:? c.slice (0); s = e, u = [], l = i.preFilter; while (s) {(n || (r = $. exec (s))) && (r && (s = s.slice (r [0] .length) || s), u.push (o = [])), n = 1, (r = I.exec (s)) && (n = r.shift (), o.push ({valor: n, tipo: r [0] .replace (W," ")}!) , s = s.slice (n.length)); para (a en i.filter) (r = U [a] .exec (s!)) || l [a] && (r = l [a]! (r)) || (n = r.shift (), o.push ({valor: n, tipo: a los partidos: r}), s = s.slice (n.length)); si (n! ) descanso} return t s.length:? s st.error (e):? e (e, u) .slice (0)} function dt (e) {var t = 0, n = e.length, r = ""; para (; n> t; t ++) r + = e [t] .value; retorno r} ht función (e, t, n) {var i = t.dir, o = n && "parentNode" === i, a = C ++; vuelva t.first función (t, n, r) {while (t = t [i]) si (1 === t.nodeType || o) de retorno e (t, n, r? )}: función (t, n, s) {var u, l, c, p = N +" "+ a; si (s) {while (t = t [i]) if ((1 === t. nodeType || O) && e (t, n, s)) return 0} else tiempo (t = t [i]) si (1 === t.nodeType || o) si (c = t [x]! | | (t [x] = {}), (L = c [i]) && l [0] === p) {if ((U = l [1]) === 0 || u === r) de retorno u === 0} else if (L = c [i] = [P], l [1] = e (t, n, !? s) || r, l [1] === 0) devuelven 0}} function gt (e) {return e.length> 1 función (t, n, r) {var i = e.length; mientras que (i -) si el retorno 1; return 0} (e [i] (t, n, r)!):! e [0]} function mt (e, t, n, r, i) {var ! O, a = [], s = 0, u = e.length, l = null = t; para (; u> s; s ++) (o = e [s]) && (n || n (o! , r, i)) && (a.push (o), l && t.push (s));! volver a} yt función (e, t, n, r, i, o) {return r && r [x] && (r = yt (r)), i &&! i [x] && (i = yt (i, o)), OT (función (o, a, s, u) {var l, c, p, f = [ ], d = [], h = a.length, g = O || xt (t || "*", s.nodeType [s]:? s, [])!, m = e || o && t!? g: mt (g, f, e, s, u), y = n i || (O e: h || r?) []: a:?? m; si (n && n (m, y, s, u), r) {l = mt (y, d), r (l, [], s, u), c = l.length; while (c -) (p = l [c]) && (y [d [c]] = (m [d [c]] = p))} Si (o) {if (i || e) {if (i) {l = [], c = y.length!; mientras que (c -) (p = y [c]) && l.push (m [c] = p); i (null, y = [], l, u)} c = y.length; while (c- -) (p = y [c]) && (l = i M.call (o, p?): f [c])> - 1 && (! O [l] = (a [l] = p))} } else y = mt (y === un y.splice (h, y.length):? y), i i (null, a, Y, u):? H.apply (a, y)})} función vt (e) {var t, n, r, o = e.length, a = i.relative [e [0] .type], s = a || i.relative [" "], u = a? 1: 0, c = ht (function (e) {return e === t}, ! S, 0), p = ht (function (e) {return M.call (t, e)> - 1}!, S, 0), f = [función (e, n, r) {return a &&! (! r || n == l) || ((t = n) .nodeType c (e, n, r):? p (e, n, r))}]; for (; o> u; u ++ ) si (n = i.relative [e [u] .type]) f = [ht (GT (f), n)]; else {si (n = i.filter [e [u] .type] .apply (null, e [u] .matches), n [x]) {for (r = ++ u; o> r; r ++) si (i.relative [e [r] .type]) romper; yt retorno ( u> 1 && GT (f), u> 1 && dt (e.slice (0, u-1)). sustituir (W, "$ 1"), n, r> u && vt (e.slice (u, r)), o> r && vt (e = e.slice (r)), o> r && dt (e))} f.push (n)} gt retorno (f)} la función bt (e, t) {var n = 0, o = t. longitud> 0, a = e.length> 0, s = function (s, u, c, f, d) {var h, g, m, y = [], v = 0, b = "0", x = s && [], w = null = d, T = L, C = s || un i.find.TAG && ( "*", d && u.parentNode || u), k = N + = null == T 1!?: Math.random () || 0,1; para (w && (l = u == p && u, r = n);! null = (h = C [b]); b ++) {if (a h &&) {g = 0 ; mientras que (m = e [g ++]) si (m (h, u, c)) {f.push (h); descanso} w && (N = k, r = ++ n)} o && ((h =! m h &&) && v -, s && x.push (h))} si (v + = B, O && b == v) {g = 0;! mientras que (m = t [g ++]) m (x, y, u, c) ; si (s) {if (v> 0), mientras que (b -) x [b] || y [b] || (y [b] = L.call (f)); y = mt (y) } H.apply (f, y), w && s && y.length> 0 && v + t.length> 1 && st.uniqueSort (f)} return w && (N = k, l = T), x};!? retorno o ot (s ): s} s = st.c Ompile = función (e, t) {var n, r = [], i = [], o = S [e +" "]; (! o) si {t || (t = ft (e)), n = t.length, mientras que (n -) o = vt (t [n]), o [x] r.push (o):? i.push (o); o = S (e, bt (i, r))} retorno o}; función xt (e, t, n) {var r = 0, i = t.length; para (; i> R; r ++) st (e, t [r], n); retorno n} function en peso (e, t, n, r) {var O, a, U, L, C, p = ft (e); if (! r && 1 === p.length) {if (a = p [0] = p [0] .slice (0), a.length> 2 && "ID" === (u = a [0]). escriba && 9 === t.nodeType &&! d && i.relative [a [1] .type]) {if (t = i.find.ID (u.matches [0] .replace (et, tt), t) [0] ,! t) de retorno n; e = e.slice (a.shift () .value.length)} o = U.needsContext.test (e) 0: a.length, mientras que (o -) {if (u = a [o], i.relative [l = u.type? ]) romper; if ((c = i.find [l]) && (r = c (u.matches [0] .replace (et, tt), V.test (a [0] .type) && t.parentNode || t))) {if (a.splice (o, 1), e = r.length && dt (a) ,! e) volver H.apply (n, q.call (r, 0)), n; descanso }}} de retorno s (e, p) (r, t, d, n, V.test (e)), n} = i.pseudos.nth i.pseudos.eq; función Tt () {} i.filters = Tt.prototype = i.pseudos, i.setFilters = new Tt, c (), st.attr = b.attr, b.find = st, b.expr = st.selectors, b.expr [ ":"] = b.expr.pseudos, b.unique = st.uniqueSort, b.text = st.getText, b.isXMLDoc = st.isXML , B.contains = st.contains} (e); var a = / Hasta $ /, st = / ^ (padres ?: | Anterior (:? Hasta | Todos)). /, Ut = / ^ [^: # \ [\,.] * $ /, = lt b.expr.match.needsContext, ct = {hijos: 0, contenidos: 0, a continuación: 0, prev:!!!! 0}; b.fn.extend ( {encontrar: function (e) {var t, n, r, i = this.length; if (! "cadena" = typeof e) de retorno r = esto, this.pushStack (b (e) .Filter (function () {for (t = 0; i> t; t ++) si (b.contains (r [t], este)) devuelven 0!})); for (n = [], t = 0; i> t; t ++ ) b.find (? e, esta [t], n); retorno n = this.pushStack (i> 1 b.unique (n): n), n.selector = (this.selector this.selector +""? : "") + e, n}, tiene: function (e) {var t, n = b (e, este), r = n.length; volver this.filter (function () {for (t = 0; r> t; t ++) si (b.contains (esto, n [t])) devuelve 0})}, no: la función (e) {return this.pushStack (ft (este, e, 1))}! , filtro: function (e) {return this.pushStack (ft (este, e, 0)!)}, es:? función (e) {return !! correo && ( "cadena" == typeof e lt.test (e ?) b (e, this.context) .index (esto [0])> = 0: b.filter (e, este) .length> 0: this.filter (e) .length> 0)}, más cercano: función (e, t) {var n, r = 0, i = this.length, o = [], a = lt.test (e) || "cadena"! = typeof e? b (e, t || this.context): 0; para (; i> R; r ++) {n = t la [r], mientras que (n && && n.ownerDocument n == == t && 11 n.nodeType!) {if (un a.index (n)> - 1:? b.find.matchesSelector (n, e)) {o. push (n); descanso} n = n.parentNode}} return this.pushStack (o.length> 1 b.unique (o): o?)}, índice: function (e) {return e "cadena" =? = typeof e b.inArray (esta [0], b (e)):? b.inArray (e.jquery e [0]:? e, esto): esta [0] && esta [0] .parentNode esto?. . primero () prevAll () longitud:. -1}, añadir: function (e, t) {var n = "string" == typeof e b (e, t):? b.makeArray (e && e.nodeType [? e]: e), r = b.merge (this.get (), n); volver this.pushStack (b.unique (r))}, addBack: function (e) {return this.add (null == e this.prevObject:? this.prevObject.filter (e))}}), b.fn.andSelf = b.fn.addBack; función pt (e, t) {hacer e = e [t], mientras que (e && 1 ! == e.nodeType); declaración electrónica} b.each ({parent: function (e) {var t = e.parentNode; retorno t && 11 == t.nodeType t: nula?}, los padres: function (e) {return b.dir (e, "parentNode")}, parentsUntil: function (e, t, n) {b.dir retorno (e, "parentNode", n)}, junto: function (e) {pt de retorno ( e, "nextSibling")}, prev: function (e) {pt retorno (e, "previousSibling")}, nextAll: function (e) {b.dir retorno (e, "nextSibli ng ")}, prevAll: function (e) {return b.dir (e," previousSibling ")}, nextUntil: function (e, t, n) {return b.dir (e," nextSibling", n)} , prevUntil: function (e, t, n) {b.dir retorno (e, "previousSibling", n)}, hermanos: function (e) {return b.sibling ((e.parentNode || {}) firstChild. , e)}, los niños: function (e) {return b.sibling (e.firstChild)}, su contenido: la función (e) {return b.nodeName (e, "iframe") || e.contentDocument e.contentWindow .document: b.merge ([], e.childNodes)}}, la función (e, t) {b.fn [e] = función (n, r) {var i = b.map (esto, t, n ); volver at.test (e) || (r = n), r && "string" == typeof r && (i = b.filter (r, i)), i = this.length> 1 && ct [e]! ? b.unique (i): i, this.length> 1 && st.test (e) && (i = i.reverse ()), this.pushStack (i)}}), b.extend ({filtro: function ( e, t, n) {return n && (e = ": no (" + e + ")"), 1 === t.length b.find.matchesSelector (t [0], e) [t [0?? ]]: []: b.find.matches (e, t)}, dir: function (e, n, r) {var i = [], o = e [n], mientras que (o && 9 == o!. nodeType && (r === t || 1 == o.nodeType || b (o) .is (r)!)) 1 === o.nodeType && i.push (o), o = O [n]; i volver}, hermano: function (e, t) {var n = []; for (; e; e = e.nextSibling) 1 === e.nodeTyp correo electrónico && && t == n.push (e);! retorno n}}); función pies (e, t, n) {if (t = t || 0, b.isFunction (t)) de retorno b.grep (e, función (e, r) {var i = !! t.call (e, r, e); retorno i === n}), si (t.nodeType) b.grep retorno (e, función (e) { volver e === t === n}), si ( "string" == typeof t) {var r = b.grep (e, función (e) {return 1 === e.nodeType}); si (ut.test (t)) de retorno b.filter (t, r, n!); t = b.filter (t, r)} b.grep retorno (e, función (e) {return b.inArray (e , t)> = 0 === n})} function dt (e) {var t = ht.split ( "|"), n = e.createDocumentFragment (); si (n.createElement), mientras que (t.length ) n.createElement (t.pop ());} n var retorno ht = "abbr | artículo | lado | audio | BDI | lienzo | datos | lista de datos | datos | figcaption | figura | pie de página | encabezado | hgroup | marca | metros | nav | salida | progreso | sección | resumen | tiempo | video "gt = / jQuery \ d + = "(?: nula | \ d +)"/ g, mt = RegExp ( "<(?:" + ht +") [\\ s />]", "i"), yt = / ^ \ s + /, vt = / <(?! área | br | col | embed | h | img | entrada | enlace | meta | param) ( ([\ w:] +) [^>] *) \ /> / gi, bt = / <([\ w:] +) / xt = / <tbody / i, p = / <| & #? ? \ w +; /, Tt = / <(guión ?: | estilo | link) / i, Nt = / ^ (casilla ?: | radio) $ / i, Ct = / comprobado \ s * (: [^ =] |. = \ s * .checked) / i, = kt / ^ $ | \ / (java ?: | ec . / I, Et = / ^ verdadera \ / (*) / ma) guión, St = / ^ \ s * <(: \ [CDATA \ [| -) | (?: \] \] |!? - -)> \ s * $ / g, A = {opción: [1, "<seleccione 'múltiple' múltiples =>", "</ select>"], la leyenda: [1, "<fieldset>", "< / fieldset> "], área: [1," <mapa> " "</ map>"], param: [1, "<objeto>", "</ object>"], thead: [1," <table> " "</ table>"], tr: [2, "<table> <tbody>", "</ tbody> </ table>"], col: [2," <table> <tbody > </ tbody> <colgroup> " "</ colgroup> </ table>"], td: [3, "<table> <tbody> <tr>"," </ tr> </ tbody> </ table> "], _ defecto:? b.support.htmlSerialize [0,"", ""]: [1, "X <div>", "</ div>"]}, Jt = dt (o), Dt = jt.appendChild (o.createElement ( "div")); At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td , b.fn.extend ({texto: function (e) {return b.access (esto, la función (e) {return e === t b.text (este):?. this.empty () append (( esta [0] && esta [0] .ownerDocument || O) .createTextNode (e))}, nula, e, arguments.length)}, wrapAll: function (e) {if (b.isFunction (e)), devuelva este each (function (t) {b (esto) .wrapAll (e.call (esto, t))}), si (esta [0]) {var t = b (e, esta [0] .ownerDocument). eq (0) .clone (0!); esta [0] .parentNode && t.in sertBefore (esta [0]), t.map (function () {var e = este, mientras que (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; retorno e}). append (esto) }} devolver este, wrapInner: function (e) {return b.isFunction (e) this.each (function (t) {b (esto) .wrapInner (e.call (esto, t))}):? esto. cada (function () {var t = b (esto), n = t.contents (); n.length n.wrapAll (e):? t.append (e)})}, envoltura: function (e) { var t = b.isFunction (e); volver this.each:}, desenvuelva: function () {(function (n) {b (esto) .wrapAll (t e.call (esto, n) e)?}) .. volver this.parent () cada uno (function () {b.nodeName (esto "cuerpo") || b (esto) .replaceWith (this.childNodes)}) final ()}, anexar: function () { volver this.domManip (argumentos, 0, la función (e) {(1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) && this.appendChild (e)}) }, anteponga: function () {return this.domManip (argumentos, 0, la función (e) {(1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType)! && this.insertBefore (e, this.firstChild)})}, antes: function () {return this.domManip (argumentos, 1, función (e) {this.parentNode && this.parentNode.insertBefore (e, this)}!)}, después: function () {return this.domManip (argumentos, ! 1, la función (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, remover: función (e, t) {var n, r = 0; para (; null = (n = esta [r]);!.! r ++) (e || b.filter (e, [n]) longitud> 0) && (t || 1 == n.nodeType || b.cleanData (Ot (n )), n.parentNode && (t && b.contains (n.ownerDocument, n) && Mt (Ot (n, "script")), n.parentNode.removeChild (n))); devuelva esta}, vacío: function () { var e, t = 0; para (; null = (e = esta [t]);! t ++) {1 === e.nodeType && b.cleanData (Ot (e, 1)!), mientras que (e.firstChild) e.removeChild (e.firstChild); e.options && b.nodeName (e, "seleccionar") && (e.options.length = 0)} devolver esta}, clon: function (e, t) {return e = null = e = 1:?! e, t = null == t e:? t, this.map (function () {return b.clone (esto, e, t)})}, html: function (e) {return b.access (esto, la función (e) {var n = esta [0] || {}, r = 0, i = this.length; si (e === t) de retorno 1 === n.nodeType? n.innerHTML.replace (gt; ""): t; if ((! "cadena" = typeof e || Tt.test (e) || b.support!!. htmlSerialize && mt.test (e) ||! b.support.leadingWhitespace && yt.test (e) || A [(bt.exec (e) || [ "", ""]) [1] .tolowercase ()])) {e = e.replace (vt, "<$ 1> </ $ 2>"); tratar {for (; i> R; r ++) n = esta [r] || {}, 1 === n.nodeType && ( b.cleanData (Ot (n, 1)!), n.innerHTML = e.), n = 0} catch (o) {}} n && this.empty () append (e)}, nula, e, arguments.length )}, sustituir con: function (e) {var t = b.isFunction (e); retorno t || "string" == typeof e || (e = b (e) .no (esto) .detach ()) , this.domManip ([e] ,! 0, la función (e) {var t = this.nextSibling, n = this.parentNode; n && (b (esto) .Remove (), n.insertBefore (e, t)) })}, separe: function (e) {return this.remove (e, 0)}, domManip: function (e, n, r) {e = f.apply ([], e); var i, o! , a, s, u, l, c = 0, p = this.length, d = este, h = p-1, g = e [0], m = b.isFunction (g), si (m || ! (1> p = || "cadena" = typeof g || b.support.checkClone!) && Ct.test (g)) volver this.each (function (i) {var o = d.eq (i); m && (e [0] = g.call (esto, i, n o.html ():? t)), o.domManip (e, n, r)}), si (p && (l = b.buildFragment ( e, esta [0] .ownerDocument,! 1, este), i = l.firstChild, 1 === l.childNodes.length && (l = i), i)) {for (n = n && b.nodeName (i, "tr"), s = b.map (Ot (l, "scrip t "), Ht), a = s.length; p> c;!!! c ++) o = l, c == h && (o = b.clone (O, 0, 0), un b.merge && (s, Ot (o "script"))), r.call (n && b.nodeName (esto [c], "mesa") Lt (esto [c], "tbody"):? esta [c], o, c) ; si (a) para (u = s [s.length-1] .ownerDocument, b.map (s, qt), c = 0; a> c; c ++) o = s [c], kt.test ( o.type || ""!) && b._data (O, "globalEval") && b.contains (u, o) && (o.src b.ajax ({url:? o.src, tipo: "GET" , Tipo de datos: "guión", asincrónico: 1, global: 1, "lanza": 0}): b.globalEval ((o.text || || o.textContent o.innerHTML || ""). sustituir (St, ""))); l = i = null} Retorno este}}); función Lt (e, t) {return e.getElementsByTagName (t) [0] || e.appendChild (e.ownerDocument. createElement (t))} function Ht (e) {var t = e.getAttributeNode ( "tipo"); retorno e.type = (t && t.specified) + "/" + e.type, e} función qt (e) {var t = Et.exec (e.type); retorno t e.type = t [1]:? e.removeAttribute ( "tipo"), e} función Mt (e, t) {var n, r = 0 ; para (;! null = (n = e [r]); r ++) b._data (! n, "globalEval", t || b._data (t [r], "globalEval"))} _t función ( e, t) {if (1 === t.nodeType && b.hasData (e)) {var n, r, i, o = b._data (e), a = b._data (t, o), s = o.events; si (s) {borrar a.handle, a.events = {}; para (n en s) para (r = 0, i = s [n] .length; i> R; r ++) b.event.add (t, n, s [n] [r])} a.data && (a.data = b.extend ({}, a.data))}} function pies (e, t) {var n, r, i; si (1 === t.nodeType) {if (n = t.nodeName.toLowerCase () ,! b.support.noCloneEvent && t [b.expando]) {i = b._data (t); para (r en i.events) b.removeEvent (t, r, i.handle); t.removeAttribute ( b.expando)} "guión" === == n && t.text e.text (Ht (t) .text = e.text, qt (t)):!? "objeto" === n (t?. parentNode && (t.outerHTML = e.outerHTML), b.support.html5Clone && e.innerHTML && b.trim (t.innerHTML) && (t.innerHTML = e.innerHTML)): "input" === n && Nt.test (e .type) (t.defaultChecked = = t.checked e.checked, t.value == e.value && (t.value = e.value!)):?? "opción" === n = t t.defaultSelected .selected = e.defaultSelected :( "entrada" === n || "área de texto" === n) && (t.defaultValue = e.defaultValue)}} b.each ({appendTo: "append", Prefijopara: "prepend", insertBefore: "antes", InsertAfter: "después", replaceAll: "sustituir con"}, la función (e, t) {b.fn [e] = function (e) {var n, r = 0, i = [], o = b (e), a = o.length-1; para (; a> = r; r ++) n = r === una esto:? (0) this.clone, b (o [r]) [t] (n), d.apply (i, n.get ()); regrese this.pushSt ACK (i)}}); función Ot (e, n) {var r, o, a = 0, s = typeof e.getElementsByTagName == i e.getElementsByTagName (n || "*"):? typeof correo !? .querySelectorAll == i e.querySelectorAll (n || "*"):; (! s) t si por (s = [], r = e.childNodes || e; = nula (o = r [! a]); a ++) n || b.nodeName (o, n) s.push (o): b.merge (s, Ot (o, n)); n de retorno === t || n && b!?. nodeName (e, n) b.merge ([e], s):? función s} Bt (e) {Nt.test (e.type) && (e.defaultChecked = e.checked)} b.extend ({ clon: function (e, t, n) {var r, i, o, a, s, u = b.contains (e.ownerDocument, e), si (b.support.html5Clone || b.isXMLDoc (e) ||! mt.test ( "<" + + e.nodeName ">")? o = e.cloneNode (0) :( Dt.innerHTML = e.outerHTML, Dt.removeChild (o = Dt.firstChild)), ! (b.support.noCloneEvent && || b.support.noCloneChecked 1! == e.nodeType && 11! == || e.nodeType b.isXMLDoc (e))) para (r = Ot (o), s = Ot (e ), a = 0; null = (i = s [a]); ++ a) r [a] && pies (i, r [a]); if (! t) si (n) para la (s = s | ! | Ot (e), r = r || Ot (o), a = 0; null = (i = s [a]); a ++) _ t (i, r [a]); lo demás _t (e, o ); de retorno r = Ot (o "script"), r.length> 0 && Mt (r, u && Ot (e, "guión"!)), r = s = i = null, o}, buildFragment: function (e, t, n, r) {var i, o, a, s, u, l, c, p = e.length, f = dt (t), d = [], h = 0; para (; P> h; h ++) si (o = E [h], o || 0 === o) si ( "objeto" === b.type (o)) b.merge (d, o.nodeType ? [o]: O); else if (wt.test (O)) {s = s || f.appendChild (t.createElement ( "div")), u = (bt.exec (o) || [ "", ""]) [1] .tolowercase (), C = A [u] || At._default, s.innerHTML = c [1] + o.replace (VT, "<$ 1> </ $ 2> ") + c [2], i = c [0]; while (i -) s = s.lastChild; if (! b.support.leadingWhitespace && yt.test (o) && d.push (t.createTextNode (yt. exec (o) [0])) ,! b.support.tbody) {o = "mesa"! == u || xt.test (o)? "<table>"! == c [1] || xt.test (o) 0: s:?! s.firstChild, i = O && o.childNodes.length, mientras que (i -) b.nodeName (l = o.childNodes [i], "tbody") && l. childNodes.length && o.removeChild (l)
} B.merge (d, s.childNodes), s.textContent = ""; while (s.firstChild) s.removeChild (s.firstChild); s = f.lastChild} else d.push (t.createTextNode (O )); s && f.removeChild (s), b.support.appendChecked || b.grep (Ot (d, "entrada"), Bt), h = 0; while (o = d [h ++]) if ((! r || -1 === b.inArray (o, r)) && (a = b.contains (o.ownerDocument, o), s = Ot (f.appendChild (o), "script"), a && Mt ( s), n)) {i = 0; while (O = s [i ++]) kt.test (o.type || "") && n.push (o)} return s = null, f}, CleanData: función (e, t) {var n, r, o, a, s = 0, u = b.expando, l = b.cache, p = b.support.deleteExpando, f = b.event.special; para (; null = (n = e [s]);! s ++) if ((t || b.acceptData (n)) && (o = n [u], a = O && l [o])) {if (a.events ) para (r en a.events) f [r] b.event.remove (n, r):? b.removeEvent (n, r, a.handle); l [o] && (eliminar l [o], p borrar n [u]: typeof n.removeAttribute == i n.removeAttribute (u):?!? n [u] = null, c.push (o))}}}); var Pt, Rt, en peso, $ t = / alfa \ ([^)] * \) / I, = / opacidad \ s * = \ s * ([^)] *) /, ZT = / ^ (arriba | right | abajo | izquierda) $ /, Xt = / ^ (ninguno |?!. mesa (- c [EA]) +) /, Ut = / ^ margen /, Vt = RegExp ( "^ (" + x + ") (*) $" , "i"), Yt = RegExp ( "^ (" + x + ") (?! px) [az%] + $", "i"), Jt = RegExp ( "^ ([+ -]) = ( "+ x +")", "I"), Gt = {BODY: "bloque"}, Qt = {position: "absoluta", la visibilidad: "oculta", pantalla: "bloque"}, Kt = {letterSpacing: 0, fontWeight: 400}, Zt = [ "Top", "derecha", "inferior", "izquierda"], en = [ "Webkit", "O", "Moz", "ms"]; función tn (e, t) {if (t en e) retorno t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = en.length; while (i -) si (t = es [i ] + n, t en e) retorno t;! retorno r} function nn (e, t) {return e = t || e, "ninguna" === b.css (e, "display") || b .contains (e.ownerDocument, e)} function rn (e, t) {var n, r, i, o = [], a = 0, s = e.length; para (; s> a; a ++) r = e [a], r.style && (o [a] = b._data (r, "olddisplay"), n = r.style.display, t? (O [a] || "ninguno"! == n || (r.style.display = "") "" === r.style.display && nn (r) && (o [a] = b._data (r, "olddisplay", ONU (r.nodeName)) )):! O [a] || (i = NN (r), (n && "ninguna" == n || i) && b._data (r, "olddisplay", e n:? b.css (r "display")))); para (a = 0; s> a;! a ++) r = e [a], r.style && (t && "ninguna" == r.style.display && "" == r .style.display || (r.style.display = t o [a] || "": "? ninguno"));} declaración electrónica b.fn.extend ({css: function (e, n) {return b.access (esto, la función (e, n, r) {var i, o, a = {}, s = 0; si (b.isArray (n)) {for (o = Rt (e), i = n.length; i> s; s ++) un [n [s]] = b.css (e, n [s] ,! 1, O);} devolver un retorno r == t b.style (e, n, r!? ): b.css (e, n)}, e, N, arguments.length> 1)}, espectáculo: function () {rn retorno (esto, 0)}, ocultar: function () {rn volver (esto )}, toggle: function (e) {var t = "boolean" == typeof e; regreso this.each (function () {(t e: nn (esto)?) b (esto) .show ():? b (esto) .hide ()})}}), b.extend ({cssHooks: {opacidad: {get: function (e, t) {if (t) {var n = Wt (e, "opacidad") !; retorno ""? === n "1": n}}}}, cssNumber: {columnCount: 0, fillOpacity: 0, fontWeight: 0, lineHeight: 0, la opacidad: 0, huérfanos :!!!!! 0, viudas: 0, zIndex: 0, zoom: 0}, cssProps: { "flotar":? b.support.cssFloat "cssFloat": "styleFloat"}, estilo: function (e, n, r, i) {if (e && 3 == e.nodeType && 8 == e.nodeType && e.style) {var o, a, s, u = b.camelCase (n), l = e.style;! si (n = b. cssProps [u] || (b.cssProps [u] = tn (l, u)), s = b.cssHooks [n] || b.cssHooks [u], r === t) de retorno s && "GET" en s && (o = s.get (e, 1, i)!) == t o:!? l [n], si (a = typeof r, "string" === a && (o = Jt.exec ( r)) && (r = (O [1] 1) * o [2] + parseFloat (b.css (e, n)), a = "número"),! nulo == r || "número ( "=== a && isNaN (r) || (" número "! == a || b.cssNumber [u] || (r + =" px "), b.suppor t.clearCloneStyle || ""! == r || 0! == n.indexOf ( "fondo") || (l [n] = "heredar"), S && "set" en s && (r = s.set (e, r, i)) === t))) try {l [n] = r} catch (c) {}}}, css: function (e, n, r, i) {var O, a , s, u = b.camelCase (n); retorno n = b.cssProps [u] || (b.cssProps [u] = tn (e.style, u)), s = b.cssHooks [n] | | b.cssHooks [u], s && "llegar" en && s (a = s.get (e, 0, r)!), una === t && (a = Peso (e, n, i)), "normal "=== a && n en el Kt && (a = Kt [n])," "=== r || r? (O = parseFloat (a), r === 0 || b.isNumeric (o)? o || 0: a): a}, swap: función (e, t, n, r) {var i, o, a = {}; para (o en t) una [o] = e.style [o] , e.style [o] = t [o]; i = n.apply (e, r || []); para (o en t) e.style [o] = a [o]; retorno i}} ), e.getComputedStyle? (Rt = función (t) {return e.getComputedStyle (t, null)}, Wt = función (e, n, r) {var i, o, a, s = r || Rt ( e), u = s s.getPropertyValue (n) || s [n]: T, L = e.style; s && retorno ( "" == u || b.contains (e.ownerDocument, e!) |? | (u = b.style (e, n)), Yt.test (u) && Ut.test (n) && (i = l.width, o = l.minWidth, a = l.maxWidth, l.minWidth = l.maxWidth = l.width = u, u = s.width, l.width = i, l.minWidth = O, = l.maxWidth a)), u}): o.documentElement.currentStyle && (Rt = function ( e) {return e.currentStyle}, WT = function (E, n, r) {var i, o, a, s = r || Rt (e), U = s s [n]:? T, l = e.style; retorno nulo == u && l && l [n] && (u = l [n]), Yt.test (u) &&! zt.test (n) && (i = l.left, o = e.runtimeStyle, a = O && o.left, a && (o.left = e.currentStyle.left), l.left = "fontSize" === n "1 em":? u, u = l.pixelLeft + "px", l.left = i, a && (o.left = a)), "" === u? "auto":? u}); función en (e, t, n) {var r = Vt.exec (t); retorno r Math.max (0, r [1] - ( n || 0)) + (r [2] || "px"): t} funcionar un (e, t, n, r, i) {var o = n === (r "frontera":?" contenido "?) 4:" ancho "? === t 1: 0, a = 0; para (; 4> O; o + = 2)" margen "=== n && (a + = b.css (e, n + Zt [o] ,! 0, i)), r? ( "contenido" === n && (a- = b.css (e, "relleno" + Zt [o] ,! 0, i))," margen "! == n && (a- = b.css (e," frontera "+ Zt [o] +" Ancho", 0, i))) :( a + = b.css (e, "relleno" + ZT [o] ,! 0, i), "relleno" == n && (a + = b.css (e, "frontera" + Zt [o] + "Ancho", 0, i!)));! devolver una } function sn (e, t, n) {var r = 0, i = "ancho" === t e.offsetWidth:!? e.offsetHeight, o = Rt (e), a = b.support.boxSizing &&" frontera-box "=== b.css (e," boxSizing", 1, o!), si (0> = i || == null i) {if (i = Peso (e, T, o), (0> i || == null i) && (i = e.style [t]), Yt.test (i)) de retorno i; r = a && (b.support.boxSizingReliable || i === e. estilo [t]), i = parseFloat (i) || 0} retu rn i + un (e, t, n || (una "frontera": "contenido"), R, O) + "px"} función de un (e) {var t = O, n = Gt [e] ;! retorno n || (n = ln (e, t), "ninguna" == n && n || (Pt = (Pt || b ( "<iframe frameborder = '0' width = '0' height = '0 '/>").css("cssText","display:block! importante ")). appendTo (t.documentElement), t = Pt [0] .contentWindow || Pt [0] .contentDocument) .document (, t.write ( "<! DOCTYPE html> <html> <body>"), t.close (), n = ln (e, t), Pt.detach ()), Gt [e] = n), n .} La función ln (e, t) {var n = b (t.createElement (e)) appendTo (t.body), r = b.css (n [0], "display"); n.remove retorno ( ), r} b.each ([ "altura", "ancho"], la función (e, n) {b.cssHooks [n] = {obtener:? función (e, r, i) {return r 0 == = e.offsetWidth && Xt.test (b.css (e, "pantalla")) b.swap (e, Qt, function () {sn retorno (e, n, i)}):? sn (e, n, i ): t}, sistema:? función (e, t, r) {var i = r && Rt (e); el retorno de la (e, t, r un (e, n, r, b.support.boxSizing && "border-box "=== b.css (e," boxSizing", 1, i!), i): 0)}}}), b.support.opacity || (b.cssHooks.opacity = {get: function (e , t) {return It.test ((t && e.currentStyle e.currentStyle.filter:? e.style.filter) || "") ?. 01 * parseFloat (RegExp $ 1) + "": t "1"? : ""}, establezca: function (e, t ) {Var n = e.style, r = e.currentStyle, i = b.isNumeric (t) "alfa (opacidad =" + 100 * t + ")":? "", O = r && r.filter || n. filtro || ""; n.zoom = 1, (t> = 1 || "" === t) && "" === b.trim (o.replace ($ t, "")) && n.removeAttribute && (n.removeAttribute ( "filtro"), "" === t || r && r.filter!) || (n.filter = $ t.test (o) o.replace ($ t, i):? O + " "+ i)}}), b (function () {|| b.support.reliableMarginRight (b.cssHooks.marginRight = {get: function (e, n)? {return n b.swap (e, {display : "inline-block"}, Wt, [e, "marginRight"]): t}}) ,! b.support.pixelPosition && b.fn.position && b.each ([ "parte superior", "izquierda"], la función (e , n) {b.cssHooks [n] = {obtener:? función (? e, r) {return r (r = Wt (e, n), Yt.test (r) b (e) .position () [ n] + "px": r): t}}})}), b.expr && b.expr.filters && (b.expr.filters.hidden = function (e) {return 0> = e.offsetWidth && 0> = e. offsetHeight ||! b.support.reliableHiddenOffsets && "ninguna" === (e.style && || e.style.display b.css (e, "pantalla"))}, b.expr.filters.visible = function (e) {return b.expr.filters.hidden (e)!}), b.each ({margin: "", padding: "", en la frontera: "Ancho"}, la función (e, t) {b.cssHooks [e t +] = {ampliar: function (n) {var r = 0, i = {}, o = "string" == typeof n n.split (" "): [n]; for (; 4> r; r ++) i [e + Zt [r] + t] = O [r] || o [r-2] ||? o [0]; volver i}}, Ut.test (e) || (b.cssHooks [e + t] .set = on)}); var cn = /% 20 / g, pn = / \ [\ ] $ /, fn = / \ r \ n / g, dn = / ^ (?: presentar botón | | imagen | restablecer | archivo)? $ / i, hn = / ^ (entrada ?: | selecto | área de texto | keygen ) /i;b.fn.extend ({serialize: function () {return b.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = b. prop (esto, "elementos"); e volver b.makeArray (e): esta}) filtro (function () {var e = this.type; volver this.name && b (esto) .es ( "?.!: discapacitados ") && hn.test (this.nodeName) &&! dn.test (e) && (this.checked ||! Nt.test (e))}). mapa (function (e, t) {var n = b (esto) .val (); return null == n nulo:?? b.isArray (n) b.map (n, la función (e) {return {nombre: t.name, valor: e.replace (fn, "\ r \ n")}}): {name: t.name, valor: n.replace (fn, "\ r \ n")}}) get ()}}), b.param = function (. e, n) {var r, i = [], o = función (e, t) {t = b.isFunction (t) t ():? nula == t "":? t, i [i.length ] = encodeURIComponent (e) + "=" + encodeURIComponent (t)}; si (n === t && (n = b.ajaxSettings && b.ajaxSettings.traditional), b.isArray (e) || e.jquery && b!. isPlai nObject (e)) b.each (e, function () {O (this.name, this.value)}); más para (r en e) gn (R, E [r], n, o); regreso i.join ( "&") sustituir (cn, "+")};. gn función (e, t, n, r) {var i; si (b.isArray (t)) b.each (t, la función (t, i) {n || pn.test (e) r (e, i):? gn (e + "[" + ( "objeto" == typeof i t:? "") + "]", i , n, r)});! else if (n || "objeto" == b.type (t)) r (e, t); más para (i en t) gn (e + "[" + i +" ] "t [i], n, r)} b.each ( "desenfoque enfoque focusin carga focusOut descarga cambiar el tamaño de desplazamiento clic dblclick mousedown mouseup mousemove encima del ratón mouseout MouseEnter mouseleave cambio seleccione enviar keydown contextual error de pulsación de tecla keyup" .split (" ") , la función (e, t) {b.fn [t] = función (e, n) {return arguments.length> 0 this.on (t, null, e, n):? this.trigger (t)}} ), b.fn.hover = function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}; var mn, yn, vn = b.now (), bn = / \? . /, x = / # * $ /, wn = / ([? &]) _ = [^ &] * /, Tn = / ^ (*.): [\ t] * ([^ \ r \ n] *) \ r $ / g, Nn = / ^ (sobre ?: | aplicaciones | app-storage | + - extensión | archivo | res | Widget):?. $ / CN = / ^ (GET ?: | HEAD) $ /, = kN / ^ \ / \ //, En = / ^ ([\ w + -.] +:) (: \ / \ / ([^ \ / #:] *?) (? :: (\ d +) |) |) /, Sn = b.fn.load, An = {}, {} = jn, Dn = "* /" co. NCAT ( "*"); try {yn = a.href} catch (Ln) {yn = o.createElement ( "a"), yn.href = "", yn = yn.href} Mn = En.exec ( yn.toLowerCase ()) || [];! función Hn (e) {función de retorno (t, n) { "string" = typeof t && (n = t, t = "*"); var r, i = 0 ., o = t.toLowerCase () partido (w) || [];? Si (b.isFunction (n)) mientras que (r = o [i ++]) "+" === r [0] (r = r.slice (1) || "*", (e [r] = e [r] || []). unshift (n)) :( e [r] = e [r] || []). push (n)}} function qn (e, n, r, i) {var o = {}, a = e === jn; función s (u) {var l;! retorno o [u] = 0, b.each (e [u] || [], la función (e, u) {var c = u (n, r, i); return "cadena" = typeof c || a || o [c]? ?! a (l = c): t: (n.dataTypes.unshift (c), s (c) ,! 1)}), l} return s (n.dataTypes [0]) || o ["! * "] && s (" * ")} la función de Mn (e, n) {var r, i, o = b.ajaxSettings.flatOptions || {};! para (i n) n [i] == t && ( (o [i] e:? r || (r = {}))! [i] = n [i]); retorno && r b.extend (0, e, r), e} = función b.fn.load (e, n, r) {if ( "cadena" = typeof && e Sn!) regresan Sn.apply (esto, argumentos); var i, o, a, s = este, u = e.indexOf (" "); return u> = 0 && (i = e.slice (u, e.length), e = e.slice (0, u)), b.isFunction (n) (r = n, n = t):? n && "objeto "== typeof n && (a =" POST "), s.length> 0 && b.ajax ({url: e, tipo: a, tipo de datos:" html", da TA:.} n) hecho (function (e) {o = argumentos, s.html (?.. I B ( "<div>") append (b.parseHTML (e)) encuentra (i): e)} ) integro (r función && (e, t) {s.each (r, o || [e.responseText, t, e])}), esta}, b.each ([ "ajaxStart", "ajaxStop"," ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], la función (e, t) {b.fn [t] = function (e) {return this.on (t, e)}}), b. cada uno ([ "obtener", "post"], la función (e, n) {b [n] = function (e, r, i, o) {return b.isFunction (r) && (o = O || i , i = r, r = t), b.ajax ({url: e, tipo: n, tipo de datos: o, los datos: r, el éxito: i})}}), b.extend ({activo: 0, lastModified : {}, etag: {}, ajaxSettings: {url: YN, tipo: "GET", isLocal: Nn.test (mn [1]), global: 0, processData: 0, asincrónico: 0, contentType : "application / x-www-form-urlencoded; charset = UTF-8" , acepta: { "*": Dn, texto: "text / plain", html: "text / html", xml: "application / xml, text / xml", JSON: "application / json , text / javascript "}, contenidos: {xml: / xml / html: / html /, JSON: / JSON /}, responseFields: {xml:" responseXML "texto: "responseText"}, convertidores: {" * texto ": e.String," texto html ": 0", el texto JSON ": b.parseJSON," XML de texto ": b.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup : function (e, t) {? t retorno Mn (Mn (e, b.ajaxSettings), t): Mn (b.ajaxSettings, e)}, ajaxPrefilter: HN (An), ajaxTransport: HN (Jn), Ajax : function (e, n) { "objeto" == typeof e && (n = e, e = t), n = n || {}; var r, i, o, a, s, u, l, c, p = b.ajaxSetup ({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) b (f):? b.event, h = b. Diferido (), g = b.Callbacks ( "una vez memoria"), m = p.statusCode || {}, y = {}, v = {}, x = 0, T = "cancelar", N = {readyState : 0, getResponseHeader:; (! c) función (e) {var t si (2 === x) {if {c = {}; while (t = Tn.exec (a)) c [t [1] .tolowercase ()] = t [2]} T = c [e.toLowerCase ()]} devolver null == t null:? t}, getAllResponseHeaders: function () {return 2 === x a:? null} , setRequestHeader: function (e, t) {var n = e.toL owerCase (); return x || (e = v [n] = v [n] || e, y [e] = t), esta}, overrideMimeType: function (e) {return x || (p.mimeType = e), esta}, statusCode: function (e) {var t; si (e) si (2> x) para (t en e) m [t] = [m [t], e [t]]; más N.always (e [N.status]); devolver esta}, abortar: function (e) {var t = e || T; retorno l && l.abort (t), k (0, t), esta}} ; si (h.promise (N) integro = g.add, N.success = N.done, N.error = N.fail, p.url = ((e || p.url || yn) +" ") .replace (xn," "). sustituir (kn, MN [1] +" // "), p.type = n.method || n.type || p.method || p.type, p .dataTypes = b.trim (p.dataType || "*") toLowerCase. (). partido (w) || [ ""], p.crossDomain == null && (r = En.exec (p.url.toLowerCase p.crossDomain = (r || r [1] === mn [1] && r [2] === mn [2] && (r [3] || ( "http:" ()),! = == r [1] 80: 443)) == (mn [3] || ( "http:" === mn [1] 80: 443)))), p.data && p.processData && "string" ! = typeof p.data && (p.data = b.param (p.data, p.traditional)), qn (An, p, n, N), 2 === x) de regreso N; u = p.global , u && 0 === b.active ++ && b.event.trigger ( "ajaxStart"), p.type = p.type.toUpperCase (), p.hasContent =! Cn.test (p.type), o = p .url, p.hasContent || (p.data && (o = p.url + = (bn.test (o) "&": "?") + p.data, eliminar p.da ta), P.Cache === 1 && (p.url = wn.test (o) o.replace (wn, "$ 1 _ =" + vn ++):?!? o + (bn.test (o) "y" :) + "_ =" + vn ++)), p.ifModified && (b.lastModified [o] && N.setRequestHeader ( "If-Modified-Since", b.lastModified [o]), b.etag [o "?" ] && N.setRequestHeader ( "If-None-Match", b.etag [o])), (p.data && && p.hasContent p.contentType! ==! 1 || n.contentType) && N.setRequestHeader ( "Content-Type" , p.contentType), N.setRequestHeader ( "Aceptar", p.dataTypes [0] [&& p.accepts p.dataTypes [0]]? [p.accepts p.dataTypes [0]] + ( "*"! = = p.dataTypes [0] ", "+ Dn +?"; q = 0,01 ":" "): p.accepts [" * "]); for (i en p.headers) N.setRequestHeader (i, p.headers [i]), si (p.beforeSend && (p.beforeSend .call (f, n, p) === 1 || 2 === x)) volver N.abort (); T = "abortar"; for (i in {éxito: 1, error: 1, completa : 1}) N [i] (p [i]), si (l = qn (jn, p, n, N)) {N.readyState = 1, u && d.trigger ( "ajaxSend", [N, p] ), p.async && p.timeout> 0 && (s = setTimeout (function () {N.abort ( "tiempo de espera")}, p.timeout)); try {x = 1, l.send (y, k)} catch (C) {(! (2> x)) si tirar C; k (-1, C)}} k más (-1, "No Transport"); función de k (e, n, r, i) {var C, Y, V, W, T, C = N;! 2 == x && (x = 2, s && clearTimeout (s), l = t, a = i || "", N.readyState = e> 0 4? : 0, r && (w = _n (p, n, r)), e> = 200 && 300> e || 304 === e (p.ifModified && (T = N.getResponseHeader ( "Last-Modified"), T &&? (b.lastModified [o] = T), T = N.getResponseHeader ( "etag"), T && (b.etag [o] = T)), 204 === e? (c = 0, C =" nocontent "):?! 304 === e (c = 0, C =" notmodified ") :( c = Fn (p, w), C = c.state, y = c.data, v = c.error , c =! v)) :( v = C, (e ||! C) && (C = "error", 0> e && (e = 0))), N.status = e, N.statusText = ( n || C) + "", c h.resolveWith (f, [Y, C, N]):? h.rejectWith (f, [N, C, v]), N.statusCode (m), m = T, U && d.trigger (c "ajaxSuccess": "ajaxError ", [N, P, C y:? V]), g.fireWith (f, [N, C]), u && (d.trigger ( "ajaxComplete", [N, p]), - b.active || b.event.trigger ( "ajaxStop")))} return N}, getScript: function (e, n) {b.get retorno (e, t, n, "script")}, getJSON: function (e , t, n) {return b.get (e, t, n, "json")}}); _n función (e, n, r) {var i, o, a, s, u = e.contents, l = e.dataTypes, c = e.responseFields; for (s en c) s en r && (n [c s []] = r [s]), mientras que ( "*" === l [0]) l .shift (), o === t && (o = || e.mimeType n.getResponseHeader ( "Content-Type")); si (o) para la (s en u) si (T [s] && T [s] .test (o)) {l.unshift (s); descanso} if (l [0] en r) a = l [0];! else {for (s en r) {if (l [0] || e.converters [s +" "+ l [0]]) {a = s; descanso} i || (i = s)} a = a || i} return un (a == l [0] && l?! .unshift (a), r [a]): función t} Fn (e, t) {var n, r, i, o, a = {}, s = 0, u = e.dataTypes.slice (), l = u [0]; si (e.dataFilter && (t = e.dataFilter (t, e.dataType)), u [1]) para (i en e.converters) un [i.toLowerCase ()] = e .converters [i]; for (; r = u [++ s];) si ( "*" == r!) {if ( "*" == l && l == r!) {if (i = a [l + " "+ r] || un [" * "+ r] ,! i) para (n en a) si (o = n.split (""), o [1] === r && (i = un [l + " "+ o [0]] || un [" *" + o [0]])) {i === 0 i = a [n]:!?! un [n] == 0 && (r = o [0], u.splice (s -, 0, r) ); Romper} if (i == 0) si (i && e [ "tira"]) t = i (t); lo demás try {t = i (t)} catch (c) {return {Estado:!! "Parsererror ", error:? i c: "No conversión de "+ l +" a "+ r}}} l = r} return {estado:" éxito", los datos: t}} b.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ECMAScript, application / x-ecmascript"}, contenidos: {script: / (java ?: | ECMA) script /}, convertidores: { "escritura de texto": function (e) {return b.globalEval (e), e}}}), b.ajaxPrefilter ( "guión", la función (e) {e.cache === t && (e.cache =! 1), e.crossDomain && (e. type = "GET", e.global =! 1)}), b.ajaxTransport ( "guión", la función (e) {if (e.crossDomain) {var n, r = o.head || b ( "cabeza ! ") [0] || o.documentElement; regreso {enviar: function (t, i) {n = o.createElement (" script "), n.async = 0, e.scriptCharset && (n.charset = e. scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) {(t || || n.readyState / cargado |! completa / .test (n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild (n), n = null, t || i (200, "éxito"))}, r.insertBefore (n, r.firstChild) }, abortar: function () {n && n.o ?? Nload (! T, 0)}}}}); var = [], Bn = / (=) \ (= & | $) | \ \ /; b.ajaxSetup ({jsonp:?? "Devolución de llamada ", jsonpCallback: function () {var e = On.pop () || b.expando + "_" + vn ++; devuelva esta [e] = 0, e!}}), b.ajaxPrefilter ( "JSON jsonp", función (n, r, i) {var o, a, s, u = n.jsonp == 1 && (Bn.test (n.url) "url":!? "cadena" == typeof n.data &&! (n.contentType || "") indexOf. ( "application / x-www-form-urlencoded") && Bn.test (n.data) && "datos"); u volver || "jsonp" === n. Tipos de datos [0] (o = = n.jsonpCallback b.isFunction (n.jsonpCallback) n.jsonpCallback ():??? n.jsonpCallback, u n [u] n = [u] .replace (Bn, "$ 1" + O): n.jsonp == 1 && (n.url + = (bn.test (n.url) "&": "?")! + n.jsonp + "=" + O), [n.converters "JSON guión"] = function () {return s || b.error (O + "no se llamaba "), s [0]}, n.dataTypes [0] =" json", a = e [o], e [o] = function () {s = argumentos}, i.always (function () {e [o] = a, n [o] && (n.jsonpCallback = r.jsonpCallback, On.push (o)) , s && b.isFunction (a) && a (s [0]), s = a = t}), "script"): t}); var Pn, Rn, Wn = 0, $ n = e.ActiveXObject && function () { var e; (! t, 0) para (e en Pn) Pn [e]}; en función () {try {return new e.XMLHttpRequest} catch (t) {}} Zn función ( ) {Try {return new e.ActiveXObject ( "Microsoft.XMLHTTP")} catch (t) {}} = b.ajaxSettings.xhr e.ActiveXObject? Function () {return! This.isLocal && En () || Zn () }: In, Rn = b.ajaxSettings.xhr (), b.support.cors = !! Rn && "withCredentials" en Rn, Rn = b.support.ajax = !! Rn, Rn && b.ajaxTransport (function (n) { si (n.crossDomain || b.support.cors!) {var r; {retorno enviar: función (i, o) {var a, s, u = n.xhr (), si (n.username u?. abierto (n.type, n.url, n.async, n.username, n.password): u.open (n.type, n.url, n.async), n.xhrFields) para (s n. xhrFields) u [s] = n.xhrFields [s]; n.mimeType && u.overrideMimeType && u.overrideMimeType (n.mimeType), n.crossDomain || i (i [ "X- [ "X-Requested-Con"] || solicitada-Con "] =" XMLHttpRequest "); tratar {for (s en i) u.setRequestHeader (s, i [s])} catch (l) {} u.send (n.hasContent && n.data || null) , r = función (e, i) {var s, l, c, p; try {si (r && (i || 4 === u.readyState)) si (r = t, a && (u.onreadystatechange = b .noop, $ n && eliminar Pn [a]), i) == 4 && u.readyState u.abort ();! else {p = {}, s = u.status, l = u.getAllResponseHeaders (), "cadena" = = typeof u.responseText && (p.text = u.responseText); try {c = u.statusTe xt} catch (f) {c = ""} s || n.isLocal || n.crossDomain 1223 === s && (s = 204):? s = p.text 200:? 404}} catch (d ) {i || o (-1, d)} p && o (s, c, p, l)}, n.async? 4 === u.readyState? setTimeout (r) :( a = ++ Wn, $ n && (Pn || (Pn = {}, b (e) .unload ($ n)), Pn [a] = r), u.onreadystatechange = r): r ()}, abortar: function () {r && r (t, 0)}}}}); var Xn, Un, Vn = / ^ (alternar ?: | espectáculo | ocultar) $ /, Yn = RegExp ( "^ (?: ([+ -]) = | ) ( "+ x +") ([az] *%) $", "i"), Jn = / queueHooks $ /, Gn = [NR], Qn = { "*": [función (e, t) { var n, r, i = this.createTween (e, t), o = Yn.exec (t), a = i.cur (), s = + a || 0, u = 1, l = 20; si (o) {if (n = + o [2], r = o [3] || (b.cssNumber [e] "?": "px"), "px" == r && s) {s = b css (i.elem, e, 0!) || n || 1; hacer u = u ||" 0.5" , s / = u, b.style (i.elem, e, s + r); mientras que (u == (u = i.cur () / a) && 1 == u && -! l)?} i.unit = r, s = i.start, i.end = O [1] s + ( o [1] 1) * n: n} return i}]}; función Kn () {return setTimeout (function () {Xn = t}), Xn = b.now ()} la función de Zn (e, t ) {b.each (t, la función (t, n) {var r = (Qn [t] || []) concat (Qn [ "*"]), i = 0, o = r.length;. para (; o> i; i ++) si (r [i] .call (e, t, n)) de retorno})} function er (e, t, n) {var r, i, o = 0, a = Gn .length, s = b.Deferred (). siempre (function () {} borrar u.elem), u = función) {if (i) r ( EEncienda 1;! var t = Xn || Kn (), n = Math.max (0, l.startTime + l.duration-t), r = n / l.duration || 0, o = 1-r, a = 0, u = l.tweens.length; para (; u> a; a ++) l.tweens [a] .run (o); volver s.notifyWith (e, [l, o, n]), 1 > o && u n:? (s.resolveWith (e, [l]) ,! 1)}, l = s.promise ({elem: e, apoyos: b.extend ({}, t), opta: b.extend (0, {specialEasing: {}}!, n), originalProperties: T, originalOptions n, horaInicio: Xn || Kn (), duración: n.duration, preadolescentes: [], createTween: función (t, n) {var r = b.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing); l.tweens.push de retorno (r), r}, detener: ? función (t) {var n = 0, r = t l.tweens.length: 0; si (i) la devolución esto, porque (! i = 0; r> n; n ++) l.tweens [n] .run (1); retorno t s.resolveWith (e, [L, T]):? s.rejectWith (e, [L, T]), esta}}), c = l.props; para (tr (c, l.opts.specialEasing); a> O; o ++) si (r = Gn [o] .call (l, e, c, l.opts)) de retorno r; volver Zn (l, c), b.isFunction ( l.opts.start) && l.opts.start.call (e, l), b.fx.timer (b.extend (u, {elem: e, anim: l, cola: l.opts.queue})) , l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail) .always (l.opts.always)} tr función (e, t) {var n, r, i, o , A; for (i en e) si (r = b.camelCase (i), o = t [r], n = e [i], b.isArray (n) && (o = n [1], n = e [i] = n [0]), i! == r && (e [r] = n, eliminar e [i]), a = b.cssHooks [r], a && "expanden" en a) {n = a.expand (n), borrar e [r]; for (i n) i en e || (e [i] = n [i], t [i] = o)} else t [r] = o} = b.Animation b.extend (er, {tweener:? función (e, t) {b.isFunction (e) (t = e, e = [ "*"]): e = e.split (" "); var n, r = 0, i = e.length; para (; i> R; r ++) n = e [r], Qn [n] = Qn [n] || [], Qn [n] .unshift (t)}, prefiltro: function (e, t) {t Gn.unshift (e):? Gn.push (e)}}); función nr (e, t, n) {var r, i, o, a, s, u, l, c, p, f = este, d = e.style, h = {}, g = [], m = e.nodeType && nn (e); n.queue || (c = b._queueHooks (e, "FX"), == null c.unqueued && (c.unqueued = 0, p = c.empty.fire, c.empty.fire = function () {c.unqueued || p ( )}), c.unqueued ++, f.always (function () {f.always (function () {c.unqueued -., b.queue (e, "FX") longitud || c.empty.fire ( )})})), 1 === e.nodeType && ( "altura" en t || "anchura" en t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], "inline "=== b.css (e," pantalla ") &&" ninguna "=== b.css (e" flotar ") && (b.support.inlineBlockNeedsLayout &&" en línea "! == ONU (e.nodeName) ? d.zoom = 1: d.display = "INLIN e-bloque ")), n.overflow && (d.overflow =" ", b.support.shrinkWrapBlocks || f.always ocultos (function () {d.overflow = n.overflow [0], d.overflowX = n .overflow [1], d.overflowY = n.overflow [2]})); para (i en t) si (a = t [i], Vn.exec (a)) {if (borrar t [i] , u = u || "cambiar" === a, a === (m "ocultar": "mostrar")) continuará; g.push (i)} if (o = g.length) {s = b._data (e, "fxshow") || b._data (e, "fxshow", {}), "escondido" en s && (m = s.hidden), u && (s.hidden =! m), m ? b (e) .show (): f.done (function () {b (e) .hide ()}), f.done (function () {var t; b._removeData (e, "fxshow") ; para (t en h) b.style (e, t, h [t])}); for (i = 0; o> i; i ++) r = g [i], l = f.createTween (r, m s [r]:? 0), h [R] = s [R] || b.style (e, r), r en s || (s [R] = l.start, m && (l.end = l.start, l.start = "anchura" === r || "altura" === r 1:? 0))}} function rr (e, t, n, r, i) {return nuevo rr .prototype.init (e, t, n, r, i)} b.Tween = rr, rr.prototype = {constructor: rr, init: function (e, t, n, r, i, o) {esto. elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = O || (b.cssNumber [n] "": "px"?)}, cur: function () {var e = rr.propHooks [this.prop]; return e && e.get ? E.get (esto): rr.propHooks._default.get (esto)}, ejecute: function (e) {var t, n = rr.propHooks [this.prop]; regreso this.pos = t = esto. options.duration b.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration):? e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, este), n && n.set n.set (esto):? rr.propHooks._default.set (esto) , esta}}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_ defecto: {get: function (e) {var t; retorno nulo == e.elem [e.prop] || e .elem.style && nula = e.elem.style [e.prop] (t = b.css (e.elem, e.prop, ""), t && "auto" == t t:? 0)!?: e.elem [e.prop]}, establezca: function (e) {b.fx.step [e.prop] b.fx.step [e.prop] (e):? e.elem.style && (nulo! = e.elem.style [b.cssProps [e.prop]] || b.cssHooks [e.prop]) b.style (e.elem, e.prop, e.now + e.unit):? e .ELEM [e.prop] = e.now}}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e .prop] = e.now)}}, b.each ([ "toggle", "show", "ocultar"], la función (e, t) {var n = b.fn [t]; b.fn [ t] = función (e, r, i) { devolver null == e || "booleano" == typeof e n.apply (esto, los argumentos):? this.animate (IR (t, 0), e, r, i!)}}), b.fn. extender ({fadeTo:.. función (e, t, n, r) {return this.filter (nn) .css ( "opacidad", 0) .show () end () animar ({opacidad: t}, e , n, r)}, animar: function (e, t, n, r) {var i = b.isEmptyObject (e), o = b.speed (t, n, r), a = function () {var t = er (esto, b.extend ({}, e), o); a.finish = function () {t.stop (0)}, (i || b._data (esto "acabado") ) && t.stop (0)}; a.finish retorno = a, i || o.queue === 1 this.each (a):!? this.queue (o.queue, a)}, parada: función (e, n, r) {var i = function (e) {var t = e.stop; eliminar e.stop, t (r)};! volver "cadena" = typeof e && (r = n, n = e, e = t), n && e! ==! 1 && this.queue (e || "FX", []), this.each (function () {var t = 0, n = null! = e && e + "queueHooks" , o = b.timers, a = b._data (esta), si (n) un [n] && un [n] .Stop && i (a [n]); más para (n en a) un [n] && un [ n] .Stop && Jn.test (n) && I (a [n]); for (n = o.length; n -;)! O [n] == .ELEM esta || nula = e && o [n]!. Cola == e || (O [n] .anim.stop (r), t = 1, o.splice (n, 1)!);! (t || r!) && b.dequeue (esto, e) })}, final: (! e) {return e == 1 && (e = e || "FX"), this.each (function () {var la función t, n = b._data (este), r = n [e + "cola"], i = n [e + "queueHooks"], o = b.timers, a = r r.length: 0; para (n.finish = 0, b.queue (esto , e, []), i && i.cur && i.cur.finish && i.cur.finish.call (este), t = o.length; t -;) o .ELEM [t] === este && o .queue [t] === e && (o [t] .anim.stop (0), o.splice (t, 1)!); para (t = 0; a> t; t ++) r [t] && r [t] .finish && r [t] .finish.call (this); eliminar n.finish})}}); función de IR (e, t) {var n, r = {altura: e}, i = 0; para (t = t? 1: 0; 4> i; i + = 2-t) n = Zt [i], r [ "margen" + n] = r [ "relleno" + n] = e; retorno t && (r.opacity = r. width = e), r} b.each ({slideDown: IR ( "show"), slideUp: IR ( "ocultar"), slideToggle: IR ( "toggle"), fadeIn: {opacidad: "show"}, fadeOut : {opacidad: "ocultar"}, fadeToggle: {opacidad: "toggle"}}, la función (e, t) {b.fn [e] = función (e, n, r) {return this.animate (t, e, n, r)}}), b.speed = function (e, t, n) {var r = e && "objeto" == typeof e b.extend ({}, e) = {completo:? n | !? | n && || t b.isFunction (e) && e, duración: e, aliviando: n && || t t && b.isFunction (t) && t}; r.duration retorno = 0 b.fx.off: "número" = ? = typeof r.duration r.duration:? r.duration en b.fx.speeds b.fx.speeds [r.duration]: b.fx.speeds._default, (null == r.queue || r. cola === 0) && (r.queue = "FX"), r.old = r.complete, r.complete = function () {b.isFunction (r.old) && r.old.call (esto), r.queue && b.dequeue (esto, r.queue) }, r}, b.easing = {lineal: function (e) {return e}, oscilación: function (e) {return.5-Math.cos (e * Math.PI) / 2}}, b.timers = [], b.fx = rr.prototype.init, b.fx.tick = function () {var e, n = b.timers, r = 0; para (Xn = b.now (); n.length > r; r ++) e = n [r], e () || n [r] == e || n.splice (r -, 1);! n.length || b.fx.stop () , Xn = t}, b.fx.timer = function (e) {e () && b. timers.push (e) && b.fx.start ()}, b.fx.interval = 13, b.fx.start = function () {Un || (Un = setInterval (b.fx.tick, b.fx .interval))}, b.fx.stop = function () {clearInterval (Un), Un = null}, b.fx.speeds = {lenta: 600, rápido: 200, _default: 400}, b.fx. paso = {}, b.expr && b.expr.filters && (b.expr.filters.animated = función (e) {return b.grep (b.timers, función de (t) {return e === t.elem}) .length}), b.fn.offset = function (e) {if (arguments.length) vuelta de correo === T este:? this.each (function (t) {b.offset.setOffset (este, e, t)}); var n, r, o = {top: 0, a la izquierda: 0}, a = esta [0], s = a && a.ownerDocument; si s) de retorno (n = s.documentElement, b.contains ( ? n, a) (typeof a.getBoundingClientRect == i && (o = a.getBoundingClientRect ()!), r = o (s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n .clientTop || 0), izquierda: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}): o}, {b.offset = setOffset: function (e, t, n) {var r = b.css (e, "posición"); "estáticos" === r && (e.style.position = "relativo"); var i = b (e), o = i.offset ( ), a = b.css (e, "parte superior"), s = b.css (e, "izquierda"), u = ( "absoluta" === r || "fija" === r) && b. InArray ( "auto", [a, s])> - 1, l = {}, c = {}, p, f;? u (c = i.position (), p = c.top, f = c.left) :( p = parseFloat (a) || 0, f = parseFloat (s) || 0), b. isFunction (t) && (t = t.call (e, n, o)), null! = t.top && (l.top = t.top-o.top + p), null! = t.left && (l .left = t.left-o.left + f), el "uso" en t t.using.call (e, l):? i.css (l)}}, b.fn.extend ({position: función () {(esta [0]) {var e, t, n = superior si {: 0, a la izquierda: 0}, r = esta [0]; retorno "fijo" === b.css (r, posición " ")? t = r.getBoundingClientRect () :( e = this.offsetParent (), t = this.offset (), b.nodeName (e [0]," HTML ") || (n = e.offset ( )), n.top + = b.css (e [0], "borderTopWidth", 0), n.left + = b.css (e [0], "borderLeftWidth", 0)), {top:! t .TOP-n.top-b.css (! r, "marginTop", 0), dejó: t.left-n.left-b.css (r, "marginLeft", 0)}}}, offsetParent: la función () {return this.map (function () {var e = || this.offsetParent o.documentElement;!, mientras que (e && b.nodeName (e, "hTML") && "estática" === b.css ( e, "posición")) e = e.offsetParent; retorno e || o.documentElement})}}), b.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, la función (e, n) {var r = / y / .test (n); b.fn [e] = función de (i) {b.access de retorno (esto, la función (e, i, o) {var a = o (e); regreso O === t? una ? N en a a [n]:? A.document.documentElement [i]:?? E [i] :( a a.scrollTo (r b (a) .scrollLeft (): o, r o:? B ( a) .scrollTop ()):? e [i] = o, t)}, e, i, arguments.length, null)}}); función o (e) {return b.isWindow (e) e: 9 === e.nodeType e.defaultView || e.parentWindow:?! 1} b.each ({altura: "altura", anchura: "ancho"}, la función (e, n) {b.each ({padding : "interior" + e, contenido: n, "": "exterior" + e}, la función de (r, i) {b.fn [i] = función (i, o) {var a = arguments.length && (r || "booleano" = typeof i), s = r || (i === 0 || O === 0 "margen":!!!? "frontera"); b.access retorno (esto, la función ( n, r, i) {var o; vuelva b.isWindow (n) n.document.documentElement [ "cliente" + e]: 9 === n.nodeType (o = n.documentElement, Math.max (?? n.body [ "scroll" + e], o [ "scroll" + e], n.body [ "offset" + e], o [ "compensar" + e], o [ "cliente" + e])) : i === t b.css (n, r, s):? b.style (n, r, i, s)}, n, a i:? t, a, null)}})}), . e.jQuery = e $ = b, "función" == typeof definir && define.amd && define.amd.jQuery && define ( "jquery", [], la función () {return b})}) (ventana);